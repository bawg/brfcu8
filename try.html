<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rugby Drill Designer</title>
    <style>
        .rugby-widget {
            width: 800px;
            height: 400px;
            border: 2px solid #333;
            background: white;
            position: relative;
            margin: 20px auto;
            overflow: hidden;
            cursor: crosshair;
        }

        .rugby-widget.playing {
            cursor: default;
        }

        .player {
            position: absolute;
            width: 14px;    /* was 12px */
            height: 14px;   /* was 12px */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            z-index: 10;
            border: 2px solid rgba(255,255,255,0.5);
        }

        .player.selected {
            border: 2px solid #333;
            box-shadow: 0 0 0 2px #ffd700;
        }

        .team-a {
            background: #e74c3c;
        }

        .team-b {
            background: #3498db;
        }

        .connection-line {
            position: absolute;
            background: rgba(0,0,0,0.4);
            height: 1px;
            transform-origin: left center;
            z-index: 5;
        }

        .movement-path {
            position: absolute;
            stroke: rgba(0,0,0,0.3);
            stroke-width: 1;
            fill: none;
            stroke-dasharray: 3,3;
            z-index: 1;
        }

        .start-position {
            position: absolute;
            width: 8px;
            height: 8px;
            border: 2px solid #333;
            background: white;
            border-radius: 50%;
            z-index: 8;
        }


        
        .waypoint-marker {
            position: absolute;
            width: 13px;    /* was 16px */
            height: 13px;   /* was 16px */
            background: #2196F3;
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            z-index: 15;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .waypoint-marker:hover {
            background: #1976D2;
            transform: scale(1.1);
        }

        .waypoint-marker.pass-waypoint-selected {
            background: #FF8C00;
            border: 3px solid #FFD700;
            box-shadow: 0 0 0 2px #FF8C00, 0 4px 8px rgba(255, 140, 0, 0.4);
        }

        .current-pass-path {
            opacity: 0.8;
        }

        .waypoint-pass-line {
            background: #FF8C00 !important;
            opacity: 0.6;
            z-index: 18 !important;
        }

        .setup-controls {
            text-align: center;
            margin: 20px 0;
            font-family: Arial, sans-serif;
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            width: 780px;
            margin: 20px auto;
        }

        .setup-row {
            margin: 10px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .setup-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
            font-family: Arial, sans-serif;
        }

        .control-btn {
            background: #333;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .control-btn:hover {
            background: #555;
        }

        .control-btn.active {
            background: #e74c3c;
        }

        .setup-btn {
            background: #2c3e50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .setup-btn:hover {
            background: #34495e;
        }

        .setup-btn.active {
            background: #27ae60;
        }

        select {
            padding: 5px 10px;
            font-size: 12px;
            border: 1px solid #ccc;
        }

        .timeline {
            width: 600px;
            margin: 10px auto;
            background: #f0f0f0;
            height: 20px;
            position: relative;
            border: 1px solid #ccc;
        }

        .timeline-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 20px;
            background: #333;
            transition: left 0.1s linear;
        }

        .info {
            text-align: center;
            margin: 10px 0;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }

        .mode-indicator {
            background: #f8f9fa;
            padding: 10px;
            text-align: center;
            font-family: Arial, sans-serif;
            font-size: 12px;
            border: 1px solid #dee2e6;
            margin: 10px auto;
            width: 780px;
        }

        .design-mode {
            background: #e8f5e8;
            border-color: #28a745;
        }

        .play-mode {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .creating-path {
            background: #fff3e0;
            border-color: #ff9800;
        }

        .code-marker {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #27ae60; /* changed from blue to green */
            border: 2px solid white;
            border-radius: 50%;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
        }
        .code-marker:hover {
            background: #219150; /* darker green on hover */
            transform: scale(1.1);
        }

        /* Add ghost marker CSS */
        .ghost-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(200,200,200,0.7);
            border: 2px dashed #888;
            border-radius: 50%;
            z-index: 5;
            pointer-events: none;
        }

        /* Ball CSS */
        .ball {
            position: absolute;
            width: 14px;
            height: 10px;
            background: #8B4513;
            border: 2px solid #A0522D;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            z-index: 25;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: all 0.1s ease;
            pointer-events: none; /* Prevent ball from intercepting clicks */
        }

        /* Pass line CSS */
        .pass-line {
            stroke: #FF8C00;
            stroke-width: 2;
            stroke-dasharray: 8,4;
            fill: none;
            z-index: 3;
            opacity: 0.8;
        }

        /* Responsive Design for Rugby Drill Designer */
        @media (max-width: 768px) {
            .info {
                padding: 16px;
                margin: 16px 8px;
            }
            
            .info h3 {
                font-size: 1.25rem;
                margin-bottom: 8px;
            }
            
            .info p {
                font-size: 14px;
                line-height: 1.4;
            }
            
            /* Make rugby widget responsive */
            .rugby-widget {
                width: calc(100vw - 32px);
                max-width: 350px;
                height: 200px;
                margin: 16px auto;
                border-width: 1px;
            }
            
            /* Adjust player markers for smaller screen */
            .player {
                width: 20px;
                height: 20px;
                font-size: 10px;
                border-width: 1px;
            }
            
            .waypoint-marker {
                width: 16px;
                height: 16px;
                font-size: 8px;
            }
            
            /* Make setup controls responsive */
            .setup-controls {
                width: calc(100vw - 32px);
                max-width: none;
                margin: 16px auto;
                padding: 12px;
            }
            
            .setup-row {
                flex-direction: column;
                gap: 12px;
                margin: 12px 0;
            }
            
            .setup-group {
                flex-direction: column;
                gap: 8px;
                align-items: stretch;
                text-align: left;
            }
            
            .setup-group label {
                font-weight: 600;
                font-size: 14px;
            }
            
            .setup-group > div {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
            }
            
            /* Make buttons more touch-friendly */
            .setup-btn, .control-btn {
                padding: 12px 16px;
                font-size: 14px;
                min-height: 44px;
                flex: 1;
                min-width: 80px;
                border-radius: 6px;
            }
            
            select {
                padding: 12px 16px;
                font-size: 16px; /* Prevent zoom on iOS */
                min-height: 44px;
                border-radius: 6px;
                width: 100%;
            }
            
            /* Controls section improvements */
            .controls {
                margin: 16px 8px;
                padding: 16px;
                background: #f8f9fa;
                border-radius: 8px;
            }
            
            .controls .control-btn {
                margin: 4px 2px;
                min-width: 70px;
                flex: 1 1 calc(25% - 4px);
            }
            
            /* Timeline improvements */
            .timeline {
                width: calc(100vw - 64px);
                max-width: 300px;
                margin: 16px auto;
            }
            
            /* Mode indicator */
            .mode-indicator {
                width: calc(100vw - 32px);
                max-width: none;
                margin: 16px auto;
                padding: 12px;
                font-size: 14px;
            }
            
            /* Ball adjustments */
            .ball {
                width: 12px;
                height: 8px;
            }
            
            .code-marker {
                width: 16px;
                height: 16px;
            }
        }
        
        /* Small mobile devices */
        @media (max-width: 480px) {
            .rugby-widget {
                width: calc(100vw - 24px);
                max-width: 300px;
                height: 180px;
            }
            
            .player {
                width: 18px;
                height: 18px;
                font-size: 9px;
            }
            
            .waypoint-marker {
                width: 14px;
                height: 14px;
                font-size: 7px;
            }
            
            .setup-controls {
                width: calc(100vw - 24px);
                padding: 10px;
            }
            
            .controls .control-btn {
                flex: 1 1 calc(50% - 4px);
                min-width: 60px;
                font-size: 12px;
                padding: 10px 8px;
            }
            
            .info {
                margin: 12px 4px;
                padding: 12px;
            }
            
            .info h3 {
                font-size: 1.1rem;
            }
            
            .timeline {
                max-width: 250px;
            }
        }
        
        /* Landscape orientation on mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            .rugby-widget {
                max-width: 450px;
                height: 180px;
            }
            
            .setup-row {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .setup-group {
                flex: 1 1 200px;
                flex-direction: row;
                align-items: center;
            }
            
            .controls .control-btn {
                flex: 1 1 calc(20% - 4px);
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js"></script>
</head>
<body>
    <div class="info">
        <h3>Rugby Drill Designer</h3>
        <p>Design custom player movements for drills or match scenarios</p>
    </div>

    <div class="setup-controls">
        <div class="setup-row">
            <div class="setup-group">
                <label>Format:</label>
                <button class="setup-btn active" id="drillModeBtn" onclick="rugbyDesigner.setMode('drill')">Drill</button>
                <button class="setup-btn" id="matchModeBtn" onclick="rugbyDesigner.setMode('match')">Match</button>
            </div>
            
            <div class="setup-group" id="drillSettings">
                <label>Players:</label>
                <select id="playerCount" onchange="rugbyDesigner.updatePlayerCount()">
                    <option value="1">1 Player</option>
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                    <option value="5" selected>5 Players</option>
                    <option value="6">6 Players</option>
                    <option value="7">7 Players</option>
                    <option value="8">8 Players</option>
                    <option value="9">9 Players</option>
                    <option value="10">10 Players</option>
                </select>
            </div>

            <div class="setup-group" id="matchSettings" style="display: none;">
                <label>Team A:</label>
                <select id="teamACount" onchange="rugbyDesigner.updateTeamCounts()">
                    <option value="1">1 Player</option>
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                    <option value="5">5 Players</option>
                    <option value="6">6 Players</option>
                    <option value="7">7 Players</option>
                    <option value="8">8 Players</option>
                    <option value="9">9 Players</option>
                    <option value="10">10 Players</option>
                    <option value="15" selected>15 Players</option>
                </select>
                <label>Team B:</label>
                <select id="teamBCount" onchange="rugbyDesigner.updateTeamCounts()">
                    <option value="1">1 Player</option>
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                    <option value="5">5 Players</option>
                    <option value="6">6 Players</option>
                    <option value="7">7 Players</option>
                    <option value="8">8 Players</option>
                    <option value="9">9 Players</option>
                    <option value="10">10 Players</option>
                    <option value="15" selected>15 Players</option>
                </select>
            </div>
        </div>
    </div>

    <div class="mode-indicator" id="modeIndicator"></div>
    
    <div class="rugby-widget" id="rugbyPitch">
        <svg class="movement-paths" style="position: absolute; width: 100%; height: 100%; pointer-events: none;">
        </svg>
        <div class="ball" id="ball" style="left: 50px; top: 200px; display: none;"></div>
    </div>

    <div class="timeline" id="timeline">
        <div class="timeline-marker" id="timelineMarker"></div>
    </div>

    <div class="controls">
        <button class="control-btn" id="designBtn" onclick="rugbyDesigner.enterDesignMode()">Design Mode</button>
        <button class="control-btn" onclick="rugbyDesigner.playMovement()">Play</button>
        <button class="control-btn" onclick="rugbyDesigner.pauseMovement()">Pause</button>
        <button class="control-btn" onclick="rugbyDesigner.resetMovement()">Reset</button>
        <button class="control-btn" onclick="rugbyDesigner.clearAll()">Clear All</button>
        <button class="control-btn" onclick="rugbyDesigner.loadSample()">Load Sample</button>
        <button class="control-btn" id="saveBtn">Save Drill</button>
        <input type="file" id="uploadInput" style="display:none" accept=".json">
        <button class="control-btn" id="uploadBtn">Upload Drill</button>
        <button class="control-btn" id="downloadGifBtn">Download GIF</button>
        <span id="gifProgress" style="font-size:12px; margin-left:10px;"></span>
    </div>
    <div class="controls" id="designControlsRow">
        <button class="control-btn" id="finishPathBtn" onclick="rugbyDesigner.finishPath()" style="display: none; background: #27ae60;">Finish Path</button>
        <button class="control-btn" id="addCodeBtn" onclick="rugbyDesigner.toggleAddCodeMode()" style="background: #2196F3; display: none;">Add Cones</button>
        <button class="control-btn" id="addPassBtn" onclick="rugbyDesigner.handlePassButton()" style="background: #FF8C00; display: none;">Add a Pass</button>
        <button class="control-btn" id="hideWaypointBtn" onclick="rugbyDesigner.toggleWaypoints()" style="background: #888; display: none;">Hide Waypoints</button>
        <button class="control-btn" id="lassoBtn" onclick="rugbyDesigner.toggleLassoMode()" style="background: #6c757d; display: none;">Move</button>
    </div>

    <script>
        class RugbyDesigner {
            constructor() {
                this.pitch = document.getElementById('rugbyPitch');
                this.timeline = document.getElementById('timeline');
                this.timelineMarker = document.getElementById('timelineMarker');
                this.modeIndicator = document.getElementById('modeIndicator');
                this.pathsSvg = this.pitch.querySelector('.movement-paths');
                this.ball = document.getElementById('ball');
                
                this.players = [];
                this.startPositions = [];
                this.waypointMarkers = [];
                this.connections = [];
                this.currentDrill = null;
                this.isPlaying = false;
                this.isDesignMode = false; // Start in play mode
                this.currentTime = 0;
                this.totalTime = 3000;
                this.animationFrame = null;
                this.selectedPlayer = null;
                this.settingEndPosition = false;
                this.mode = 'drill';
                this.playerCount = 5;
                this.teamACount = 15;
                this.teamBCount = 15;
                this.codes = [];
                this.isAddCodeMode = false;
                this.waypointsHidden = false;
                this.lassoMode = false;
                this.draggedObject = null;
                this.dragOffset = { x: 0, y: 0 };
                
                // Pass-related properties
                this.passes = [];
                this.isAddPassMode = false;
                this.selectedPasser = null;
                this.ballCarrier = null;
                this.ballAnimationPromise = null;
                this.ballAnimatingAlongPass = false;
                
                // Waypoint-based pass properties
                this.currentPassWaypoints = [];
                this.isCreatingWaypointPass = false;
                
                this.bindEvents();
                this.initPlayers();
                this.setupSaveUpload();
                this.setupGifExport();

                // Set initial mode indicator to blank
                this.modeIndicator.innerHTML = '';
            }

            toggleLassoMode() {
                this.lassoMode = !this.lassoMode;
                document.getElementById('lassoBtn').classList.toggle('active', this.lassoMode);
                document.getElementById('lassoBtn').textContent = this.lassoMode ? 'Exit Move' : 'Move';
                this.updateModeIndicator(this.lassoMode ? 'Move: Drag players to reposition.' : 'Design Mode');
            }

            bindEvents() {
                this.pitch.addEventListener('click', (e) => this.handlePitchClick(e));
                this.pitch.addEventListener('contextmenu', (e) => this.handleRightClick(e));
                this.pitch.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
                this.pitch.addEventListener('click', (e) => this.handleCodeClick(e));
                this.pitch.addEventListener('dblclick', (e) => this.handleCodeDoubleClick(e));
                this.pitch.addEventListener('mousedown', (e) => this.handleLassoDown(e));
                document.addEventListener('mousemove', (e) => this.handleLassoMove(e));
                document.addEventListener('mouseup', (e) => this.handleLassoUp(e));
            }

            setMode(mode) {
                this.mode = mode;
                document.getElementById('drillModeBtn').classList.toggle('active', mode === 'drill');
                document.getElementById('matchModeBtn').classList.toggle('active', mode === 'match');
                document.getElementById('drillSettings').style.display = mode === 'drill' ? 'flex' : 'none';
                document.getElementById('matchSettings').style.display = mode === 'match' ? 'flex' : 'none';
                
                this.clearAllPlayers();
                this.initPlayers();
            }

            updatePlayerCount() {
                if (this.mode !== 'drill') return;
                this.playerCount = parseInt(document.getElementById('playerCount').value);
                this.clearAllPlayers();
                this.initPlayers();
            }

            updateTeamCounts() {
                if (this.mode !== 'match') return;
                this.teamACount = parseInt(document.getElementById('teamACount').value);
                this.teamBCount = parseInt(document.getElementById('teamBCount').value);
                this.clearAllPlayers();
                this.initPlayers();
            }

            clearAllPlayers() {
                this.players.forEach(player => player.remove());
                this.startPositions.forEach(pos => pos.remove());
                this.waypointMarkers.forEach(marker => marker.remove());
                this.connections.forEach(line => line.remove());
                this.players = [];
                this.startPositions = [];
                this.waypointMarkers = [];
                this.connections = [];
                this.selectedPlayer = null;
                this.settingEndPosition = false;
                this.pathsSvg.innerHTML = '';
                this.codes.forEach(code => code.remove());
                this.codes = [];
            }

            initPlayers() {
                // Ensure container dimensions are available
                setTimeout(() => {
                    if (this.mode === 'drill') {
                        this.initDrillPlayers();
                    } else {
                        this.initMatchPlayers();
                    }
                    this.drawConnections();
                    this.updateModeDisplay();
                }, 10); // Small delay to ensure CSS has been applied
            }

            initDrillPlayers() {
                // Get actual container dimensions for responsive positioning
                const containerWidth = this.pitch.offsetWidth || 800;
                const containerHeight = this.pitch.offsetHeight || 400;
                
                const spacing = Math.min(60, (containerWidth * 0.75) / this.playerCount);
                const startX = containerWidth * 0.125 + ((containerWidth * 0.75) - (this.playerCount - 1) * spacing) / 2;
                const centerY = containerHeight / 2;
                
                for (let i = 0; i < this.playerCount; i++) {
                    this.createPlayer(startX + i * spacing, centerY, 'team-a', i + 1);
                }
            }

            initMatchPlayers() {
                // Get actual container dimensions for responsive positioning
                const containerWidth = this.pitch.offsetWidth || 800;
                const containerHeight = this.pitch.offsetHeight || 400;
                
                const teamASpacing = Math.min(40, (containerHeight * 0.875) / this.teamACount);
                const teamAStartY = containerHeight / 2 - (this.teamACount - 1) * teamASpacing / 2;
                
                for (let i = 0; i < this.teamACount; i++) {
                    this.createPlayer(containerWidth * 0.1875, teamAStartY + i * teamASpacing, 'team-a', i + 1);
                }
                
                const teamBSpacing = Math.min(40, (containerHeight * 0.875) / this.teamBCount);
                const teamBStartY = containerHeight / 2 - (this.teamBCount - 1) * teamBSpacing / 2;
                
                for (let i = 0; i < this.teamBCount; i++) {
                    this.createPlayer(containerWidth * 0.8125, teamBStartY + i * teamBSpacing, 'team-b', i + 1);
                }
            }

            createPlayer(x, y, team, number) {
                const player = document.createElement('div');
                player.className = `player ${team}`;
                player.style.left = x + 'px';
                player.style.top = y + 'px';
                player.textContent = number;
                player.dataset.startX = x;
                player.dataset.startY = y;
                player.dataset.endX = x;
                player.dataset.endY = y;
                player.dataset.team = team;
                player.dataset.number = number;
                
                this.pitch.appendChild(player);
                this.players.push(player);
                
                const startPos = document.createElement('div');
                startPos.className = 'start-position';
                startPos.style.left = (x + 2) + 'px';
                startPos.style.top = (y + 2) + 'px';
                this.pitch.appendChild(startPos);
                this.startPositions.push(startPos);
            }

            updateModeDisplay() {
                if (this.isDesignMode) {
                    const modeText = this.mode === 'drill'
                        ? `DESIGN MODE (${this.playerCount} players): Click on a player to start creating their movement path`
                        : `DESIGN MODE (Team A: ${this.teamACount}, Team B: ${this.teamBCount}): Click on a player to start creating their movement path`;
                    this.modeIndicator.innerHTML = `<strong>${modeText}</strong>`;
                    this.modeIndicator.className = 'mode-indicator design-mode';
                } else {
                    // Blank in play mode
                    this.modeIndicator.innerHTML = '';
                    this.modeIndicator.className = 'mode-indicator play-mode';
                }
            }

            updateModeIndicator(text) {
                this.modeIndicator.innerHTML = `<strong>${text}</strong>`;
            }

            handlePitchClick(e) {
                if (!this.isDesignMode || this.isPlaying) return;
                
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const clickedPlayer = this.getPlayerAt(x, y);
                const clickedWaypoint = this.getWaypointAt(x, y);
                
                // Handle waypoint-based pass creation mode
                if (this.isAddPassMode && clickedWaypoint) {
                    this.addWaypointToPass(clickedWaypoint);
                    return;
                }
                
                // In pass mode, only allow waypoint selection - no player selection
                if (this.isAddPassMode && clickedPlayer) {
                    // Inform user they need to use waypoints
                    this.updateModeIndicator('Pass mode: Please click on waypoints, not players. Create waypoints first by exiting pass mode.');
                    return;
                }
                
                // Handle normal waypoint creation
                if (clickedPlayer && !this.settingEndPosition && !this.isAddPassMode) {
                    // Start creating a path for this player
                    this.selectPlayer(clickedPlayer);
                    this.settingEndPosition = true;
                    if (!this.selectedPlayer.waypoints) {
                        this.selectedPlayer.waypoints = [];
                    }
                    this.showPathCreationMode();
                } else if (this.settingEndPosition && this.selectedPlayer && !clickedPlayer && !clickedWaypoint) {
                    // Add waypoint (only if we didn't click on a player or existing waypoint)
                    this.addWaypoint(this.selectedPlayer, x, y);
                    this.updateWaypointMarkers();
                    this.drawPaths();
                }
            }

            handleDoubleClick(e) {
                if (!this.isDesignMode || this.isPlaying) return;
                
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const clickedWaypoint = this.getWaypointAt(x, y);
                if (clickedWaypoint) {
                    this.deleteWaypoint(clickedWaypoint);
                }
            }

            getWaypointAt(x, y) {
                return this.waypointMarkers.find(marker => {
                    const mx = parseInt(marker.style.left);
                    const my = parseInt(marker.style.top);
                    const distance = Math.sqrt((x - mx - 8) ** 2 + (y - my - 8) ** 2);
                    return distance < 12;
                });
            }

            showPathCreationMode() {
                const playerNum = this.selectedPlayer.dataset.number;
                const teamColor = this.selectedPlayer.dataset.team === 'team-a' ? 'Red' : 'Blue';
                
                this.modeIndicator.innerHTML = `
                    <strong>CREATING PATH for Player ${playerNum} (${teamColor})</strong><br>
                    Click on the field to add waypoints. Click "Finish Path" button when done.
                `;
                this.modeIndicator.className = 'mode-indicator creating-path';
                
                // Show the finish path button
                document.getElementById('finishPathBtn').style.display = 'inline-block';
            }

            getPlayerAt(x, y) {
                return this.players.find(player => {
                    const px = parseInt(player.style.left);
                    const py = parseInt(player.style.top);
                    const distance = Math.sqrt((x - px - 6) ** 2 + (y - py - 6) ** 2);
                    return distance < 15;
                });
            }

            selectPlayer(player) {
                if (this.selectedPlayer) {
                    this.selectedPlayer.classList.remove('selected');
                }
                this.selectedPlayer = player;
                player.classList.add('selected');
            }

            setPlayerEndPosition(player, x, y) {
                player.dataset.endX = x - 6;
                player.dataset.endY = y - 6;
            }

            addWaypoint(player, x, y) {
                if (!player.waypoints) {
                    player.waypoints = [];
                }
                const waypointData = { x: x - 6, y: y - 6, player: player };
                player.waypoints.push(waypointData);
                
                // Update end position to the latest waypoint
                player.dataset.endX = x - 6;
                player.dataset.endY = y - 6;
                
                const playerNum = player.dataset.number;
                const teamColor = player.dataset.team === 'team-a' ? 'Red' : 'Blue';
                
                this.modeIndicator.innerHTML = `
                    <strong>CREATING PATH for Player ${playerNum} (${teamColor})</strong><br>
                    Waypoint ${player.waypoints.length} added! Continue clicking to add more waypoints, or click "Finish Path" when done.<br>
                    <small>Double-click any blue waypoint to delete it</small>
                `;
            }

            updateWaypointMarkers() {
                // Clear existing waypoint markers
                this.waypointMarkers.forEach(marker => marker.remove());
                this.waypointMarkers = [];
                
                // Create new waypoint markers for all players
                this.players.forEach(player => {
                    if (player.waypoints && player.waypoints.length > 0) {
                        player.waypoints.forEach((waypoint, index) => {
                            this.createWaypointMarker(waypoint, index + 1, player);
                        });
                    }
                });
            }

            createWaypointMarker(waypoint, number, player) {
                const marker = document.createElement('div');
                marker.className = 'waypoint-marker';
                marker.style.left = (waypoint.x + 6 - 8) + 'px'; // Center the marker
                marker.style.top = (waypoint.y + 6 - 8) + 'px';   // Center the marker
                marker.textContent = number;
                marker.dataset.player = player.dataset.number;
                marker.dataset.team = player.dataset.team;
                marker.dataset.waypointIndex = number - 1;
                
                // Store reference to waypoint data
                marker.waypointData = waypoint;
                marker.ownerPlayer = player;
                
                this.pitch.appendChild(marker);
                this.waypointMarkers.push(marker);
            }

            deleteWaypoint(waypointMarker) {
                const player = waypointMarker.ownerPlayer;
                const waypointIndex = parseInt(waypointMarker.dataset.waypointIndex);
                
                // Remove waypoint from player's waypoints array
                player.waypoints.splice(waypointIndex, 1);
                
                // Update end position
                if (player.waypoints.length > 0) {
                    const lastWaypoint = player.waypoints[player.waypoints.length - 1];
                    player.dataset.endX = lastWaypoint.x;
                    player.dataset.endY = lastWaypoint.y;
                } else {
                    // No waypoints left, reset to start position
                    player.dataset.endX = player.dataset.startX;
                    player.dataset.endY = player.dataset.startY;
                }
                
                // Update display
                this.updateWaypointMarkers();
                this.drawPaths();
                
                // Update status message if we're currently editing this player
                if (this.selectedPlayer === player) {
                    const playerNum = player.dataset.number;
                    const teamColor = player.dataset.team === 'team-a' ? 'Red' : 'Blue';
                    this.modeIndicator.innerHTML = `
                        <strong>CREATING PATH for Player ${playerNum} (${teamColor})</strong><br>
                        Waypoint deleted! ${player.waypoints.length} waypoints remaining. Continue clicking to add more waypoints.<br>
                        <small>Double-click any blue waypoint to delete it</small>
                    `;
                }
            }

            handleRightClick(e) {
                e.preventDefault();
                
                // Handle finishing waypoint pass creation
                if (this.isAddPassMode && this.isCreatingWaypointPass && this.currentPassWaypoints.length >= 2) {
                    this.finishWaypointPass();
                    return;
                }
                
                // Handle finishing regular path creation
                if (this.settingEndPosition && this.selectedPlayer) {
                    this.finishPath();
                }
            }

            finishPath() {
                if (this.selectedPlayer) {
                    this.settingEndPosition = false;
                    this.selectedPlayer.classList.remove('selected');
                    this.selectedPlayer = null;
                    
                    // Hide the finish path button
                    document.getElementById('finishPathBtn').style.display = 'none';
                    
                    // Make sure waypoint markers are updated
                    this.updateWaypointMarkers();
                    this.updateModeDisplay();
                    this.drawConnections();
                    this.drawPaths();
                }
            }

            drawConnections() {
                this.connections.forEach(line => line.remove());
                this.connections = [];

                if (this.mode === 'drill') {
                    for (let i = 0; i < this.players.length - 1; i++) {
                        const player1 = this.players[i];
                        const player2 = this.players[i + 1];
                        this.createConnection(player1, player2);
                    }
                } else {
                    const teamAPlayers = this.players.filter(p => p.dataset.team === 'team-a');
                    const teamBPlayers = this.players.filter(p => p.dataset.team === 'team-b');
                    
                    for (let i = 0; i < teamAPlayers.length - 1; i++) {
                        this.createConnection(teamAPlayers[i], teamAPlayers[i + 1]);
                    }
                    
                    for (let i = 0; i < teamBPlayers.length - 1; i++) {
                        this.createConnection(teamBPlayers[i], teamBPlayers[i + 1]);
                    }
                }
            }

            createConnection(player1, player2) {
                const x1 = parseInt(player1.style.left) + 6;
                const y1 = parseInt(player1.style.top) + 6;
                const x2 = parseInt(player2.style.left) + 6;
                const y2 = parseInt(player2.style.top) + 6;
                
                const line = document.createElement('div');
                line.className = 'connection-line';
                
                const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                line.style.left = x1 + 'px';
                line.style.top = y1 + 'px';
                line.style.width = length + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                
                this.pitch.appendChild(line);
                this.connections.push(line);
            }

            drawPaths() {
                this.pathsSvg.innerHTML = '';
                
                this.players.forEach(player => {
                    const startX = parseInt(player.dataset.startX) + 6;
                    const startY = parseInt(player.dataset.startY) + 6;
                    
                    // Get all path points
                    const pathPoints = [{ x: startX, y: startY }];
                    
                    if (player.waypoints && player.waypoints.length > 0) {
                        player.waypoints.forEach(waypoint => {
                            pathPoints.push({ x: waypoint.x + 6, y: waypoint.y + 6 });
                        });
                    } else {
                        const endX = parseInt(player.dataset.endX) + 6;
                        const endY = parseInt(player.dataset.endY) + 6;
                        if (startX !== endX || startY !== endY) {
                            pathPoints.push({ x: endX, y: endY });
                        }
                    }
                    
                    // Draw path lines
                    if (pathPoints.length > 1) {
                        for (let i = 0; i < pathPoints.length - 1; i++) {
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            const d = `M ${pathPoints[i].x} ${pathPoints[i].y} L ${pathPoints[i + 1].x} ${pathPoints[i + 1].y}`;
                            path.setAttribute('d', d);
                            path.setAttribute('class', 'movement-path');
                            
                            if (this.mode === 'match') {
                                const color = player.dataset.team === 'team-a' ? 'rgba(231,76,60,0.5)' : 'rgba(52,152,219,0.5)';
                                path.setAttribute('stroke', color);
                            }
                            
                            this.pathsSvg.appendChild(path);
                        }
                        
                        // Draw direction arrows
                        for (let i = 0; i < pathPoints.length - 1; i++) {
                            this.drawArrow(pathPoints[i], pathPoints[i + 1], player.dataset.team);
                        }
                    }
                });
                
                // Draw passes after drawing movement paths
                this.drawPasses();
            }

            drawArrow(startPoint, endPoint, team) {
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length < 20) return; // Skip arrows for very short segments
                
                // Calculate arrow position (midpoint of segment)
                const arrowX = startPoint.x + dx * 0.6;
                const arrowY = startPoint.y + dy * 0.6;
                
                // Calculate arrow angle
                const angle = Math.atan2(dy, dx);
                
                // Arrow size
                const arrowSize = 8;
                
                // Calculate arrow points
                const arrowPoint1X = arrowX - arrowSize * Math.cos(angle - Math.PI / 6);
                const arrowPoint1Y = arrowY - arrowSize * Math.sin(angle - Math.PI / 6);
                const arrowPoint2X = arrowX - arrowSize * Math.cos(angle + Math.PI / 6);
                const arrowPoint2Y = arrowY - arrowSize * Math.sin(angle + Math.PI / 6);
                
                // Create arrow
                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const points = `${arrowX},${arrowY} ${arrowPoint1X},${arrowPoint1Y} ${arrowPoint2X},${arrowPoint2Y}`;
                arrow.setAttribute('points', points);
                
                const color = this.mode === 'match' 
                    ? (team === 'team-a' ? '#e74c3c' : '#3498db')
                    : '#333';
                
                arrow.setAttribute('fill', color);
                arrow.setAttribute('stroke', 'white');
                arrow.setAttribute('stroke-width', '0.5');
                
                this.pathsSvg.appendChild(arrow);
            }

            enterDesignMode() {
                // Toggle design mode state
                this.isDesignMode = !this.isDesignMode;

                if (this.isDesignMode) {
                    // Enter design mode
                    this.pauseMovement();
                    this.resetMovement();
                    this.pitch.classList.remove('playing');
                    document.getElementById('designBtn').classList.add('active');
                    document.getElementById('addCodeBtn').style.display = 'inline-block';
                    document.getElementById('addPassBtn').style.display = 'inline-block';
                    document.getElementById('hideWaypointBtn').style.display = 'inline-block';
                    document.getElementById('lassoBtn').style.display = 'inline-block';
                    this.setWaypointsVisible(!this.waypointsHidden);
                    
                    // Hide ball in design mode
                    this.ball.style.display = 'none';

                    // Set main control buttons to dark grey
                    const mainBtns = document.querySelectorAll('.controls:not(#designControlsRow) .control-btn');
                    mainBtns.forEach(btn => {
                        btn.style.background = '#333';
                        btn.style.color = 'white';
                    });

                    // Set design-only buttons to light grey
                    document.getElementById('addCodeBtn').style.background = '#e0e0e0';
                    document.getElementById('addCodeBtn').style.color = '#333';
                    document.getElementById('addPassBtn').style.background = '#e0e0e0';
                    document.getElementById('addPassBtn').style.color = '#333';
                    document.getElementById('hideWaypointBtn').style.background = '#e0e0e0';
                    document.getElementById('hideWaypointBtn').style.color = '#333';
                    document.getElementById('lassoBtn').style.background = '#e0e0e0';
                    document.getElementById('lassoBtn').style.color = '#333';

                    this.updateModeDisplay(); // <-- Always call this here
                } else {
                    // Enter play mode
                    this.settingEndPosition = false;
                    if (this.selectedPlayer) {
                        this.selectedPlayer.classList.remove('selected');
                        this.selectedPlayer = null;
                    }
                    this.pitch.classList.add('playing');
                    document.getElementById('designBtn').classList.remove('active');
                    document.getElementById('addCodeBtn').style.display = 'none';
                    document.getElementById('addPassBtn').style.display = 'none';
                    document.getElementById('hideWaypointBtn').style.display = 'none';
                    document.getElementById('lassoBtn').style.display = 'none';

                    this.updateModeDisplay(); // <-- Always call this here
                }
            }

            playMovement() {
                if (!this.isDesignMode) {
                    if (this.isPlaying) return;
                    this.generateCurrentDrill(); // <-- Add this line
                    
                    // Show ball in play mode
                    if (this.players.length > 0) {
                        this.ballCarrier = this.players[0];
                        this.updateBallPosition();
                    }
                    
                    this.isPlaying = true;
                    this.animateMovement();
                } else {
                    this.enterPlayMode();
                    setTimeout(() => this.playMovement(), 100);
                }
            }

            enterPlayMode() {
                this.isDesignMode = false;
                this.settingEndPosition = false;
                if (this.selectedPlayer) {
                    this.selectedPlayer.classList.remove('selected');
                    this.selectedPlayer = null;
                }
                this.pitch.classList.add('playing');
                document.getElementById('hideWaypointBtn').style.display = 'none';
                document.getElementById('lassoBtn').style.display = 'none';
                this.updateModeIndicator(this.mode === 'drill' ? 'PLAYING DRILL' : 'PLAYING MATCH');
            }

            generateCurrentDrill() {
                const movements = this.players.map(player => {
                    const startX = parseInt(player.dataset.startX);
                    const startY = parseInt(player.dataset.startY);
                    
                    // Build complete path including waypoints
                    const pathPoints = [{ x: startX, y: startY }];
                    
                    if (player.waypoints && player.waypoints.length > 0) {
                        player.waypoints.forEach(waypoint => {
                            pathPoints.push({ x: waypoint.x, y: waypoint.y });
                        });
                    } else {
                        const endX = parseInt(player.dataset.endX);
                        const endY = parseInt(player.dataset.endY);
                        if (startX !== endX || startY !== endY) {
                            pathPoints.push({ x: endX, y: endY });
                        }
                    }
                    
                    // Calculate total distance for constant speed
                    let totalDistance = 0;
                    for (let i = 0; i < pathPoints.length - 1; i++) {
                        const dx = pathPoints[i + 1].x - pathPoints[i].x;
                        const dy = pathPoints[i + 1].y - pathPoints[i].y;
                        totalDistance += Math.sqrt(dx * dx + dy * dy);
                    }
                    
                    return {
                        pathPoints,
                        totalDistance,
                        startX,
                        startY
                    };
                });

                this.currentDrill = { movements, totalTime: this.totalTime };
            }

            animateMovement() {
                const startTime = Date.now();
                
                // Initialize ball carrier (first player with ball)
                if (!this.ballCarrier && this.players.length > 0) {
                    this.ballCarrier = this.players[0];
                }
                
                // Reset pass execution flags
                this.passes.forEach(pass => pass.executed = false);
                
                const animate = () => {
                    if (!this.isPlaying) return;
                    
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / this.totalTime, 1);
                    
                    this.players.forEach((player, index) => {
                        const movement = this.currentDrill.movements[index];
                        const position = this.getPositionAlongPath(movement, progress);
                        
                        player.style.left = position.x + 'px';
                        player.style.top = position.y + 'px';
                    });
                    
                    // Update ball position to follow carrier (only if not animating along pass)
                    if (!this.ballAnimatingAlongPass) {
                        this.updateBallPosition();
                    }
                    
                    // Check for pass execution at 80% progress
                    this.passes.forEach((pass) => {
                        if (!pass.executed) {
                            // Handle different types of passes
                            if (pass.type === 'waypoint-sequence') {
                                // For waypoint-sequence passes, execute when any player is at 80% progress
                                // Find the passer (first waypoint's owner)
                                if (pass.waypoints && pass.waypoints.length >= 2) {
                                    const firstWaypoint = pass.waypoints[0];
                                    const passer = firstWaypoint.ownerPlayer;
                                    
                                    if (this.ballCarrier === passer) {
                                        const passerMovement = this.currentDrill.movements[this.players.indexOf(passer)];
                                        const passerProgress = this.getMovementProgress(passerMovement, progress);
                                        
                                        if (passerProgress >= 0.8) {
                                            pass.executed = true;
                                            
                                            // Set flag to prevent ball position updates during animation
                                            this.ballAnimatingAlongPass = true;
                                            
                                            // Create path from waypoints
                                            const ballPath = pass.waypoints.map(waypoint => ({
                                                x: parseInt(waypoint.style.left) + 8, // Center of waypoint
                                                y: parseInt(waypoint.style.top) + 8
                                            }));
                                            
                                            // Animate ball along the path
                                            this.animateBallAlongPath(ballPath, 880).then(() => {
                                                // Transfer ball to the last waypoint's owner (receiver)
                                                const lastWaypoint = pass.waypoints[pass.waypoints.length - 1];
                                                this.ballCarrier = lastWaypoint.ownerPlayer;
                                                
                                                // Clear flag after animation completes
                                                this.ballAnimatingAlongPass = false;
                                            });
                                        }
                                    }
                                }
                            } else if (pass.passer && pass.receiver) {
                                // Handle traditional passer-receiver passes
                                if (this.ballCarrier === pass.passer) {
                                    const passerMovement = this.currentDrill.movements[this.players.indexOf(pass.passer)];
                                    const passerProgress = this.getMovementProgress(passerMovement, progress);
                                    
                                    if (passerProgress >= 0.8) {
                                        pass.executed = true;
                                        
                                        // Set flag to prevent ball position updates during animation
                                        this.ballAnimatingAlongPass = true;
                                        
                                        // Use consistent pass origin - same as in drawPasses
                                        let passerStartX, passerStartY;
                                        
                                        if (pass.passer.waypoints && pass.passer.waypoints.length > 0) {
                                            // Use the last waypoint as the pass origin
                                            const lastWaypoint = pass.passer.waypoints[pass.passer.waypoints.length - 1];
                                            passerStartX = lastWaypoint.x;
                                            passerStartY = lastWaypoint.y;
                                        } else {
                                            // Use start position if no waypoints
                                            passerStartX = parseFloat(pass.passer.dataset.startX);
                                            passerStartY = parseFloat(pass.passer.dataset.startY);
                                        }
                                        
                                        // Animate ball from passer's pass origin to receiver's target
                                        this.animateBallToWaypoint(
                                            passerStartX + 6, passerStartY + 6,
                                            pass.targetX + 6, pass.targetY + 6,
                                            880
                                        ).then(() => {
                                            // Transfer ball to receiver
                                            this.ballCarrier = pass.receiver;
                                            
                                            // Clear flag after animation completes
                                            this.ballAnimatingAlongPass = false;
                                        });
                                    }
                                }
                            }
                        }
                    });
                    
                    this.timelineMarker.style.left = (progress * (this.timeline.offsetWidth - 2)) + 'px';
                    
                    if (progress < 1) {
                        this.animationFrame = requestAnimationFrame(animate);
                    } else {
                        this.isPlaying = false;
                    }
                };
                
                animate();
            }

            getMovementProgress(movement, overallProgress) {
                // Calculate progress along a specific player's movement path
                const { pathPoints, totalDistance } = movement;
                
                if (pathPoints.length <= 1 || totalDistance === 0) {
                    return overallProgress;
                }
                
                const targetDistance = totalDistance * overallProgress;
                let currentDistance = 0;
                
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const dx = pathPoints[i + 1].x - pathPoints[i].x;
                    const dy = pathPoints[i + 1].y - pathPoints[i].y;
                    const segmentDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (currentDistance + segmentDistance >= targetDistance) {
                        const segmentProgress = (targetDistance - currentDistance) / segmentDistance;
                        return (i + segmentProgress) / (pathPoints.length - 1);
                    }
                    
                    currentDistance += segmentDistance;
                }
                
                return 1.0;
            }

            getPositionAlongPath(movement, progress) {
                const { pathPoints, totalDistance } = movement;
                
                if (pathPoints.length <= 1) {
                    return { x: pathPoints[0].x, y: pathPoints[0].y };
                }
                
                // Calculate target distance along path
                const targetDistance = totalDistance * progress;
                
                // Find which segment we're on
                let currentDistance = 0;
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const dx = pathPoints[i + 1].x - pathPoints[i].x;
                    const dy = pathPoints[i + 1].y - pathPoints[i].y;
                    const segmentDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (currentDistance + segmentDistance >= targetDistance) {
                        // We're on this segment
                        const segmentProgress = (targetDistance - currentDistance) / segmentDistance;
                        
                        return {
                            x: pathPoints[i].x + dx * segmentProgress,
                            y: pathPoints[i].y + dy * segmentProgress
                        };
                    }
                    
                    currentDistance += segmentDistance;
                }
                
                // If we're past the end, return the last point
                return { x: pathPoints[pathPoints.length - 1].x, y: pathPoints[pathPoints.length - 1].y };
            }

            pauseMovement() {
                this.isPlaying = false;
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
            }

            resetMovement() {
                this.pauseMovement();
                this.currentTime = 0;
                this.timelineMarker.style.left = '0px';
                
                this.players.forEach(player => {
                    player.style.left = player.dataset.startX + 'px';
                    player.style.top = player.dataset.startY + 'px';
                });
                
                // Reset ball and passes
                if (this.players.length > 0) {
                    this.ballCarrier = this.players[0];
                    this.ballAnimatingAlongPass = false;
                    this.updateBallPosition();
                }
                this.passes.forEach(pass => pass.executed = false);
            }

            clearAll() {
                this.pauseMovement();
                this.resetMovement();
                this.players.forEach(player => {
                    player.dataset.endX = player.dataset.startX;
                    player.dataset.endY = player.dataset.startY;
                    player.waypoints = [];
                });
                this.updateWaypointMarkers();
                this.drawPaths();
                this.enterDesignMode();
                this.codes.forEach(code => code.remove());
                this.codes = [];
                
                // Clear passes and all pass-related DOM elements
                this.passes = [];
                this.drawPasses();
                
                // Remove all pass-related lines including waypoint-pass-lines
                this.pathsSvg.querySelectorAll('.pass-line').forEach(line => line.remove());
                this.pitch.querySelectorAll('.waypoint-pass-line').forEach(line => line.remove());
                this.pitch.querySelectorAll('.current-pass-path').forEach(line => line.remove());
                
                // Clear pass-related state
                this.ballCarrier = null;
                this.ballAnimatingAlongPass = false;
                this.ball.style.display = 'none';
                this.selectedPasser = null;
                this.currentPassWaypoints = [];
                this.isCreatingWaypointPass = false;
                this.clearPassWaypointHighlights();
            }

            loadSample() {
                this.clearAll();
                
                // Create a sample movement pattern with waypoints
                this.players.forEach((player, index) => {
                    const baseX = parseInt(player.dataset.startX);
                    const baseY = parseInt(player.dataset.startY);
                    
                    // Initialize waypoints array
                    player.waypoints = [];
                    
                    // Create different movement patterns with multiple waypoints
                    if (this.mode === 'drill') {
                        // Create zigzag patterns, cutting moves, and loops
                        if (index % 3 === 0) {
                            // Zigzag pattern
                            player.waypoints.push({ x: baseX + 80, y: baseY - 40 });
                            player.waypoints.push({ x: baseX + 120, y: baseY + 40 });
                            player.waypoints.push({ x: baseX + 180, y: baseY - 20 });
                        } else if (index % 3 === 1) {
                            // Sharp cutting move
                            player.waypoints.push({ x: baseX + 100, y: baseY });
                            player.waypoints.push({ x: baseX + 120, y: baseY - 60 });
                            player.waypoints.push({ x: baseX + 200, y: baseY - 80 });
                        } else {
                            // Loop back pattern
                            player.waypoints.push({ x: baseX + 60, y: baseY + 50 });
                            player.waypoints.push({ x: baseX + 140, y: baseY + 60 });
                            player.waypoints.push({ x: baseX + 160, y: baseY - 30 });
                            player.waypoints.push({ x: baseX + 120, y: baseY - 50 });
                        }
                    } else {
                        // Match scenario movements with tactical patterns
                        if (player.dataset.team === 'team-a') {
                            if (index % 2 === 0) {
                                // Attacking line with dummy and cut
                                player.waypoints.push({ x: baseX + 80, y: baseY + 20 });
                                player.waypoints.push({ x: baseX + 120, y: baseY - 30 });
                                player.waypoints.push({ x: baseX + 200, y: baseY - 40 });
                            } else {
                                // Support run with loop
                                player.waypoints.push({ x: baseX + 60, y: baseY - 40 });
                                player.waypoints.push({ x: baseX + 140, y: baseY - 20 });
                            }
                        } else {
                            if (index % 2 === 0) {
                                // Defensive drift
                                player.waypoints.push({ x: baseX - 60, y: baseY - 20 });
                                player.waypoints.push({ x: baseX - 120, y: baseY - 40 });
                                player.waypoints.push({ x: baseX - 160, y: baseY - 30 });
                            } else {
                                // Counter-attack run
                                player.waypoints.push({ x: baseX - 80, y: baseY + 30 });
                                player.waypoints.push({ x: baseX - 40, y: baseY + 60 });
                                player.waypoints.push({ x: baseX + 40, y: baseY + 40 });
                            }
                        }
                    }
                    
                    // Set end position to last waypoint
                    if (player.waypoints.length > 0) {
                        const lastWaypoint = player.waypoints[player.waypoints.length - 1];
                        player.dataset.endX = lastWaypoint.x;
                        player.dataset.endY = lastWaypoint.y;
                    }
                });
                
                // Add sample passes to demonstrate pass features
                if (this.players.length >= 3) {
                    // Pass from player 1 to player 2's waypoint
                    this.createPass(this.players[0], this.players[1]);
                    
                    // Pass from player 2 to player 3's waypoint  
                    this.createPass(this.players[1], this.players[2]);
                }
                
                this.drawPaths();
                this.updateModeIndicator('Sample loaded with movement patterns and passes! Orange dashed lines show passes to waypoints. Click Play to see ball animation.');
            }



            createPass(passer, receiver) {
                // Get receiver's end position (waypoint or starting position)
                let receiverEndX, receiverEndY;
                
                // If receiver has waypoints, use the last waypoint position
                if (receiver.waypoints && receiver.waypoints.length > 0) {
                    const lastWaypoint = receiver.waypoints[receiver.waypoints.length - 1];
                    receiverEndX = lastWaypoint.x;
                    receiverEndY = lastWaypoint.y;
                } else {
                    // Use the dataset end position as fallback
                    receiverEndX = parseFloat(receiver.dataset.endX);
                    receiverEndY = parseFloat(receiver.dataset.endY);
                }
                
                const pass = {
                    passer: passer,
                    receiver: receiver,
                    targetX: receiverEndX,
                    targetY: receiverEndY,
                    executed: false
                };
                
                this.passes.push(pass);
                this.drawPasses();
            }

            drawPasses() {
                // Remove existing pass lines from SVG
                this.pathsSvg.querySelectorAll('.pass-line').forEach(line => line.remove());
                
                // Draw pass lines
                this.passes.forEach(pass => {
                    if (pass.type === 'waypoint-sequence') {
                        // For waypoint-sequence passes, draw lines between waypoints
                        if (pass.waypoints && pass.waypoints.length >= 2) {
                            for (let i = 0; i < pass.waypoints.length - 1; i++) {
                                const fromWaypoint = pass.waypoints[i];
                                const toWaypoint = pass.waypoints[i + 1];
                                
                                const fromX = parseInt(fromWaypoint.style.left) + 8;
                                const fromY = parseInt(fromWaypoint.style.top) + 8;
                                const toX = parseInt(toWaypoint.style.left) + 8;
                                const toY = parseInt(toWaypoint.style.top) + 8;
                                
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                const d = `M ${fromX} ${fromY} L ${toX} ${toY}`;
                                line.setAttribute('d', d);
                                line.setAttribute('class', 'pass-line');
                                
                                this.pathsSvg.appendChild(line);
                            }
                        }
                    } else if (pass.passer && pass.receiver) {
                        // Traditional passer-receiver passes - draw from passer's pass origin to receiver target
                        let passerX, passerY;
                        
                        // Use the same pass origin calculation as the animation
                        if (pass.passer.waypoints && pass.passer.waypoints.length > 0) {
                            // Use the last waypoint as the pass origin
                            const lastWaypoint = pass.passer.waypoints[pass.passer.waypoints.length - 1];
                            passerX = lastWaypoint.x + 6;
                            passerY = lastWaypoint.y + 6;
                        } else {
                            // Use start position if no waypoints
                            passerX = parseFloat(pass.passer.dataset.startX) + 6;
                            passerY = parseFloat(pass.passer.dataset.startY) + 6;
                        }
                        
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const d = `M ${passerX} ${passerY} L ${pass.targetX + 6} ${pass.targetY + 6}`;
                        line.setAttribute('d', d);
                        line.setAttribute('class', 'pass-line');
                        
                        this.pathsSvg.appendChild(line);
                    }
                });
            }

            updateBallPosition() {
                if (this.ballCarrier) {
                    const carrierX = parseFloat(this.ballCarrier.style.left) + 6;
                    const carrierY = parseFloat(this.ballCarrier.style.top) + 6;
                    this.ball.style.left = (carrierX - 6) + 'px';
                    this.ball.style.top = (carrierY - 6) + 'px';
                    this.ball.style.display = 'block';
                }
            }

            animateBallToWaypoint(fromX, fromY, toX, toY, duration = 500) {
                return new Promise((resolve) => {
                    const startTime = Date.now();
                    const initialX = fromX;
                    const initialY = fromY;
                    
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        
                        // Smooth easing
                        const easedProgress = 1 - Math.pow(1 - progress, 3);
                        
                        const currentX = initialX + (toX - initialX) * easedProgress;
                        const currentY = initialY + (toY - initialY) * easedProgress;
                        
                        this.ball.style.left = (currentX - 6) + 'px';
                        this.ball.style.top = (currentY - 6) + 'px';
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    
                    animate();
                });
            }

            // New method to animate ball along a path of waypoints
            async animateBallAlongPath(waypoints, totalDuration = 800) {
                if (waypoints.length < 2) return;
                
                // Calculate segment durations based on distances
                const segments = [];
                let totalDistance = 0;
                
                for (let i = 0; i < waypoints.length - 1; i++) {
                    const dx = waypoints[i + 1].x - waypoints[i].x;
                    const dy = waypoints[i + 1].y - waypoints[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    segments.push({ from: waypoints[i], to: waypoints[i + 1], distance });
                    totalDistance += distance;
                }
                
                // Animate through each segment
                for (const segment of segments) {
                    const segmentDuration = (segment.distance / totalDistance) * totalDuration;
                    await this.animateBallToWaypoint(
                        segment.from.x, segment.from.y,
                        segment.to.x, segment.to.y,
                        segmentDuration
                    );
                }
            }

            toggleAddCodeMode() {
                this.isAddCodeMode = !this.isAddCodeMode;
                document.getElementById('addCodeBtn').classList.toggle('active', this.isAddCodeMode);
                this.updateModeIndicator(this.isAddCodeMode ? 'Add Code mode: Click on the pitch to add a code. Double-click a code to remove.' : 'Design Mode');
            }

            toggleAddPassMode() {
                this.isAddPassMode = !this.isAddPassMode;
                if (this.isAddPassMode) {
                    // Exit other modes
                    this.isAddCodeMode = false;
                    this.lassoMode = false;
                    document.getElementById('addCodeBtn').classList.remove('active');
                    document.getElementById('lassoBtn').classList.remove('active');
                    document.getElementById('lassoBtn').textContent = 'Move';
                    
                    // Reset pass creation state
                    this.selectedPasser = null;
                    this.currentPassWaypoints = [];
                    this.isCreatingWaypointPass = false;
                    document.getElementById('addPassBtn').classList.add('active');
                    document.getElementById('addPassBtn').textContent = 'Finish Pass';
                    this.updateModeIndicator('Select the waypoint where the pass originates');
                } else {
                    // Reset all pass-related state
                    this.selectedPasser = null;
                    this.currentPassWaypoints = [];
                    this.isCreatingWaypointPass = false;
                    this.clearPassWaypointHighlights();
                    document.getElementById('addPassBtn').classList.remove('active');
                    document.getElementById('addPassBtn').textContent = 'Add a Pass';
                    this.updateModeIndicator('Design Mode');
                }
            }

            handlePassButton() {
                if (!this.isAddPassMode) {
                    // Not in pass mode - start pass mode
                    this.toggleAddPassMode();
                } else if (this.isCreatingWaypointPass && this.currentPassWaypoints.length >= 2) {
                    // In pass mode with a pass in progress - finish the current pass
                    this.finishWaypointPass();
                } else {
                    // In pass mode but no pass in progress - exit pass mode
                    this.toggleAddPassMode();
                }
            }

            clearPassWaypointHighlights() {
                // Remove highlights from all waypoints in the current pass
                this.currentPassWaypoints.forEach(waypoint => {
                    if (waypoint && waypoint.classList) {
                        waypoint.classList.remove('pass-waypoint-selected');
                    }
                });
                
                // Remove temporary pass path visualization
                const tempPaths = this.pitch.querySelectorAll('.current-pass-path');
                tempPaths.forEach(path => path.remove());
            }

            addWaypointToPass(waypoint) {
                // Add the waypoint to the current pass sequence
                this.currentPassWaypoints.push(waypoint);
                waypoint.classList.add('pass-waypoint-selected');
                this.isCreatingWaypointPass = true;
                
                if (this.currentPassWaypoints.length === 1) {
                    this.updateModeIndicator('Pass origin selected. Click on additional waypoints to build the pass path. Right-click to finish.');
                } else {
                    this.updateModeIndicator(`Pass path: ${this.currentPassWaypoints.length} waypoints selected. Click more waypoints or right-click to finish.`);
                }
                
                // Draw the pass path visualization
                this.drawCurrentPassPath();
            }

            drawCurrentPassPath() {
                // Remove existing pass path visualization
                const existingPaths = this.pitch.querySelectorAll('.current-pass-path');
                existingPaths.forEach(path => path.remove());
                
                if (this.currentPassWaypoints.length < 2) return;
                
                // Draw lines connecting the waypoints in the current pass
                for (let i = 0; i < this.currentPassWaypoints.length - 1; i++) {
                    const from = this.currentPassWaypoints[i];
                    const to = this.currentPassWaypoints[i + 1];
                    
                    const fromX = parseInt(from.style.left) + 8; // Center of waypoint
                    const fromY = parseInt(from.style.top) + 8;
                    const toX = parseInt(to.style.left) + 8;
                    const toY = parseInt(to.style.top) + 8;
                    
                    const line = document.createElement('div');
                    line.className = 'current-pass-path';
                    line.style.position = 'absolute';
                    line.style.background = '#FF8C00';
                    line.style.height = '3px';
                    line.style.zIndex = '20';
                    line.style.pointerEvents = 'none';
                    
                    const length = Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);
                    const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
                    
                    line.style.width = length + 'px';
                    line.style.left = fromX + 'px';
                    line.style.top = fromY + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.transformOrigin = 'left center';
                    
                    this.pitch.appendChild(line);
                }
            }

            finishWaypointPass() {
                if (this.currentPassWaypoints.length >= 2) {
                    // Create a pass object representing the waypoint sequence
                    const passData = {
                        type: 'waypoint-sequence',
                        waypoints: [...this.currentPassWaypoints],
                        id: Date.now() // Simple ID for tracking
                    };
                    
                    // Add to passes array for potential future use
                    this.passes.push(passData);
                    
                    // Convert current pass path lines to permanent ones
                    const tempPaths = this.pitch.querySelectorAll('.current-pass-path');
                    tempPaths.forEach(path => {
                        path.classList.remove('current-pass-path');
                        path.classList.add('waypoint-pass-line');
                    });
                    
                    this.updateModeIndicator(`Pass path created with ${this.currentPassWaypoints.length} waypoints! Click on waypoints to create another pass.`);
                    
                    // Reset state but keep pass mode active for creating additional passes
                    this.currentPassWaypoints = [];
                    this.isCreatingWaypointPass = false;
                    
                    // Remove temporary highlights
                    this.clearPassWaypointHighlights();
                }
            }

            handleCodeClick(e) {
                if (!this.isAddCodeMode || this.isPlaying || this.mode !== 'drill') return;
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                // Prevent adding code if clicking on a player or waypoint
                if (this.getPlayerAt(x, y) || this.getWaypointAt(x, y)) return;
                if (this.getCodeAt(x, y)) return;
                this.addCode(x, y);
            }

            handleCodeDoubleClick(e) {
                if (!this.isAddCodeMode || this.isPlaying || this.mode !== 'drill') return;
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const code = this.getCodeAt(x, y);
                if (code) {
                    this.removeCode(code);
                }
            }

            addCode(x, y) {
                const code = document.createElement('div');
                code.className = 'code-marker';
                code.style.left = (x - 7) + 'px';
                code.style.top = (y - 7) + 'px';
                this.pitch.appendChild(code);
                this.codes.push(code);
            }

            getCodeAt(x, y) {
                return this.codes.find(code => {
                    const cx = parseInt(code.style.left);
                    const cy = parseInt(code.style.top);
                    const distance = Math.sqrt((x - cx - 7) ** 2 + (y - cy - 7) ** 2);
                    return distance < 10;
                });
            }

            removeCode(code) {
                code.remove();
                this.codes = this.codes.filter(c => c !== code);
            }

            toggleWaypoints() {
                this.waypointsHidden = !this.waypointsHidden;
                this.setWaypointsVisible(!this.waypointsHidden);
                document.getElementById('hideWaypointBtn').textContent = this.waypointsHidden ? 'Show Waypoints' : 'Hide Waypoints';
            }

            setWaypointsVisible(visible) {
                this.waypointMarkers.forEach(marker => {
                    marker.style.display = visible ? 'flex' : 'none';
                });
            }

            handleLassoDown(e) {
                if (!this.lassoMode || this.isPlaying || !this.isDesignMode) return;
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check for player
                const player = this.getPlayerAt(x, y);
                if (player) {
                    this.draggedObject = { type: 'player', obj: player };
                    this.dragOffset.x = x - parseInt(player.style.left);
                    this.dragOffset.y = y - parseInt(player.style.top);
                    e.preventDefault();
                    return;
                }
                // Check for waypoint
                const waypoint = this.getWaypointAt(x, y);
                if (waypoint) {
                    this.draggedObject = { type: 'waypoint', obj: waypoint };
                    this.dragOffset.x = x - parseInt(waypoint.style.left);
                    this.dragOffset.y = y - parseInt(waypoint.style.top);
                    e.preventDefault();
                    return;
                }
                // Check for cone
                const cone = this.getCodeAt(x, y);
                if (cone) {
                    this.draggedObject = { type: 'cone', obj: cone };
                    this.dragOffset.x = x - parseInt(cone.style.left);
                    this.dragOffset.y = y - parseInt(cone.style.top);
                    e.preventDefault();
                    return;
                }
            }

            handleLassoMove(e) {
                if (!this.lassoMode || !this.draggedObject) return;
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                if (this.draggedObject.type === 'player') {
                    const player = this.draggedObject.obj;
                    player.style.left = (x - this.dragOffset.x) + 'px';
                    player.style.top = (y - this.dragOffset.y) + 'px';
                    player.dataset.startX = parseInt(player.style.left);
                    player.dataset.startY = parseInt(player.style.top);
                    player.dataset.endX = player.dataset.startX;
                    player.dataset.endY = player.dataset.startY;

                    // Update the corresponding start-position marker
                    const playerIndex = this.players.indexOf(player);
                    if (playerIndex !== -1) {
                        const startPos = this.startPositions[playerIndex];
                        startPos.style.left = (player.dataset.startX + 2) + 'px';
                        startPos.style.top = (player.dataset.startY + 2) + 'px';
                    }

                    this.drawConnections();
                    this.drawPaths();
                } else if (this.draggedObject.type === 'waypoint') {
                    const marker = this.draggedObject.obj;
                    marker.style.left = (x - this.dragOffset.x) + 'px';
                    marker.style.top = (y - this.dragOffset.y) + 'px';
                    // Update waypoint data
                    const waypoint = marker.waypointData;
                    waypoint.x = parseInt(marker.style.left) + 8 - 6; // adjust for marker offset
                    waypoint.y = parseInt(marker.style.top) + 8 - 6;
                    marker.ownerPlayer.dataset.endX = waypoint.x;
                    marker.ownerPlayer.dataset.endY = waypoint.y;
                    this.drawPaths();
                } else if (this.draggedObject.type === 'cone') {
                    const cone = this.draggedObject.obj;
                    cone.style.left = (x - this.dragOffset.x) + 'px';
                    cone.style.top = (y - this.dragOffset.y) + 'px';
                }
            }

            handleLassoUp(e) {
                if (!this.lassoMode) return;
                this.draggedObject = null;
            }

            setupSaveUpload() {
                document.getElementById('saveBtn').onclick = () => this.saveDrill();
                document.getElementById('uploadBtn').onclick = () => document.getElementById('uploadInput').click();
                document.getElementById('uploadInput').onchange = (e) => this.uploadDrill(e);
            }

            setupGifExport() {
                document.getElementById('downloadGifBtn').onclick = () => this.exportGif();
                this.gifProgress = document.getElementById('gifProgress');
            }

            saveDrill() {
                const drillName = prompt("Enter a name for this drill:");
                if (!drillName) return;

                // Gather drill data
                const data = {
                    name: drillName,
                    mode: this.mode,
                    playerCount: this.playerCount,
                    teamACount: this.teamACount,
                    teamBCount: this.teamBCount,
                    players: this.players.map((player, i) => ({
                        team: player.dataset.team,
                        number: player.dataset.number,
                        startX: player.dataset.startX,
                        startY: player.dataset.startY,
                        endX: player.dataset.endX,
                        endY: player.dataset.endY,
                        waypoints: player.waypoints ? player.waypoints.map(wp => ({ x: wp.x, y: wp.y })) : []
                    })),
                    codes: this.codes.map(code => ({
                        left: code.style.left,
                        top: code.style.top
                    }))
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: "application/json" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `${drillName.replace(/\s+/g, '_')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            uploadDrill(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    try {
                        const data = JSON.parse(evt.target.result);
                        this.loadDrillData(data);
                    } catch (err) {
                        alert("Invalid drill file.");
                    }
                };
                reader.readAsText(file);
            }

            exportGif() {
                if (this.isPlaying) {
                    alert("Please pause the animation before exporting.");
                    return;
                }
                this.gifProgress.textContent = "Generating GIF...";

                this.generateCurrentDrill();

                const frames = 40;
                const duration = this.totalTime;
                const frameDelay = Math.round(duration / frames / 10); // gif.js uses delay in 1/100s

                const gif = new window.GIF({
                    workers: 2,
                    quality: 10,
                    width: this.pitch.offsetWidth,
                    height: this.pitch.offsetHeight,
                    workerScript: 'gif.worker.js'
                });

                // Hide overlays for GIF
                const overlays = [this.timeline, this.modeIndicator];
                overlays.forEach(el => el.style.visibility = 'hidden');

                // Helper to capture a frame and add to GIF
                const captureFrame = (progress, cb) => {
                    // Move players to correct positions
                    this.players.forEach((player, idx) => {
                        const movement = this.currentDrill.movements[idx];
                        const pos = this.getPositionAlongPath(movement, progress);
                        player.style.left = pos.x + 'px';
                        player.style.top = pos.y + 'px';
                    });
                    this.timelineMarker.style.left = (progress * (this.timeline.offsetWidth - 2)) + 'px';

                    html2canvas(this.pitch, {
                        scale: 1
                    }).then(canvas => {
                        gif.addFrame(canvas, {delay: frameDelay});
                        cb();
                    });
                };

                let i = 0;
                const nextFrame = () => {
                    if (i > frames) {
                        overlays.forEach(el => el.style.visibility = 'visible');
                        this.gifProgress.textContent = "Rendering GIF...";
                        gif.on('finished', (blob) => {
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'rugby_drill.gif';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            this.gifProgress.textContent = "GIF downloaded!";
                        });
                        gif.render();
                        return;
                    }
                    const progress = i / frames;
                    this.gifProgress.textContent = `Capturing frames... ${i + 1}/${frames + 1}`;
                    captureFrame(progress, () => {
                        i++;
                        setTimeout(nextFrame, 10);
                    });
                };
                nextFrame();
            }

            loadDrillData(data) {
                // Set mode and player counts
                this.setMode(data.mode || 'drill');
                if (data.mode === 'drill') {
                    this.playerCount = data.playerCount || 5;
                    document.getElementById('playerCount').value = this.playerCount;
                } else {
                    this.teamACount = data.teamACount || 15;
                    this.teamBCount = data.teamBCount || 15;
                    document.getElementById('teamACount').value = this.teamACount;
                    document.getElementById('teamBCount').value = this.teamBCount;
                }
                this.clearAllPlayers();

                // Recreate players
                (data.players || []).forEach((pdata, i) => {
                    this.createPlayer(
                        parseInt(pdata.startX),
                        parseInt(pdata.startY),
                        pdata.team,
                        pdata.number
                    );
                    const player = this.players[this.players.length - 1];
                    player.dataset.endX = pdata.endX;
                    player.dataset.endY = pdata.endY;
                    player.waypoints = (pdata.waypoints || []).map(wp => ({ x: wp.x, y: wp.y, player }));
                });

                // Recreate codes
                (data.codes || []).forEach(cdata => {
                    this.addCode(parseInt(cdata.left) + 7, parseInt(cdata.top) + 7);
                });

                this.updateWaypointMarkers();
                this.drawConnections();
                this.drawPaths();
                this.updateModeIndicator(`Loaded drill: ${data.name || 'Unnamed'}`);
            }
        }

        // Initialize the app
        let rugbyDesigner;
        document.addEventListener('DOMContentLoaded', () => {
            rugbyDesigner = new RugbyDesigner();
        });
    </script>
</body>
</html>