<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rugby Drill Designer</title>
    <style>
        .rugby-widget {
            width: 800px;
            height: 400px;
            border: 2px solid #333;
            background: white;
            position: relative;
            margin: 20px auto;
            overflow: hidden;
            cursor: crosshair;
        }

        .rugby-widget.playing {
            cursor: default;
        }

        .player {
            position: absolute;
            width: 14px;    /* was 12px */
            height: 14px;   /* was 12px */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            z-index: 10;
            border: 2px solid rgba(255,255,255,0.5);
        }

        .player.selected {
            border: 2px solid #333;
            box-shadow: 0 0 0 2px #ffd700;
        }

        .team-a {
            background: #e74c3c;
        }

        .team-b {
            background: #3498db;
        }

        .connection-line {
            position: absolute;
            background: rgba(0,0,0,0.4);
            height: 1px;
            transform-origin: left center;
            z-index: 5;
        }

        .movement-path {
            position: absolute;
            stroke: rgba(0,0,0,0.3);
            stroke-width: 1;
            fill: none;
            stroke-dasharray: 3,3;
            z-index: 1;
        }

        .start-position {
            position: absolute;
            width: 8px;
            height: 8px;
            border: 2px solid #333;
            background: white;
            border-radius: 50%;
            z-index: 8;
        }


        
        .waypoint-marker {
            position: absolute;
            width: 13px;    /* was 16px */
            height: 13px;   /* was 16px */
            background: #2196F3;
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            z-index: 15;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .waypoint-marker:hover {
            background: #1976D2;
            transform: scale(1.1);
        }

        .setup-controls {
            text-align: center;
            margin: 20px 0;
            font-family: Arial, sans-serif;
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #dee2e6;
            width: 780px;
            margin: 20px auto;
        }

        .setup-row {
            margin: 10px 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .setup-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
            font-family: Arial, sans-serif;
        }

        .control-btn {
            background: #333;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .control-btn:hover {
            background: #555;
        }

        .control-btn.active {
            background: #e74c3c;
        }

        .setup-btn {
            background: #2c3e50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .setup-btn:hover {
            background: #34495e;
        }

        .setup-btn.active {
            background: #27ae60;
        }

        select {
            padding: 5px 10px;
            font-size: 12px;
            border: 1px solid #ccc;
        }

        .timeline {
            width: 600px;
            margin: 10px auto;
            background: #f0f0f0;
            height: 20px;
            position: relative;
            border: 1px solid #ccc;
        }

        .timeline-marker {
            position: absolute;
            top: 0;
            width: 2px;
            height: 20px;
            background: #333;
            transition: left 0.1s linear;
        }

        .info {
            text-align: center;
            margin: 10px 0;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }

        .mode-indicator {
            background: #f8f9fa;
            padding: 10px;
            text-align: center;
            font-family: Arial, sans-serif;
            font-size: 12px;
            border: 1px solid #dee2e6;
            margin: 10px auto;
            width: 780px;
        }

        .design-mode {
            background: #e8f5e8;
            border-color: #28a745;
        }

        .play-mode {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .creating-path {
            background: #fff3e0;
            border-color: #ff9800;
        }

        .code-marker {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #27ae60; /* changed from blue to green */
            border: 2px solid white;
            border-radius: 50%;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
        }
        .code-marker:hover {
            background: #219150; /* darker green on hover */
            transform: scale(1.1);
        }

        /* Add ghost marker CSS */
        .ghost-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(200,200,200,0.7);
            border: 2px dashed #888;
            border-radius: 50%;
            z-index: 5;
            pointer-events: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js"></script>
</head>
<body>
    <div class="info">
        <h3>Rugby Drill Designer</h3>
        <p>Design custom player movements for drills or match scenarios</p>
    </div>

    <div class="setup-controls">
        <div class="setup-row">
            <div class="setup-group">
                <label>Format:</label>
                <button class="setup-btn active" id="drillModeBtn" onclick="rugbyDesigner.setMode('drill')">Drill</button>
                <button class="setup-btn" id="matchModeBtn" onclick="rugbyDesigner.setMode('match')">Match</button>
            </div>
            
            <div class="setup-group" id="drillSettings">
                <label>Players:</label>
                <select id="playerCount" onchange="rugbyDesigner.updatePlayerCount()">
                    <option value="1">1 Player</option>
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                    <option value="5" selected>5 Players</option>
                    <option value="6">6 Players</option>
                    <option value="7">7 Players</option>
                    <option value="8">8 Players</option>
                    <option value="9">9 Players</option>
                    <option value="10">10 Players</option>
                </select>
            </div>

            <div class="setup-group" id="matchSettings" style="display: none;">
                <label>Team A:</label>
                <select id="teamACount" onchange="rugbyDesigner.updateTeamCounts()">
                    <option value="1">1 Player</option>
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                    <option value="5">5 Players</option>
                    <option value="6">6 Players</option>
                    <option value="7">7 Players</option>
                    <option value="8">8 Players</option>
                    <option value="9">9 Players</option>
                    <option value="10">10 Players</option>
                    <option value="15" selected>15 Players</option>
                </select>
                <label>Team B:</label>
                <select id="teamBCount" onchange="rugbyDesigner.updateTeamCounts()">
                    <option value="1">1 Player</option>
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                    <option value="5">5 Players</option>
                    <option value="6">6 Players</option>
                    <option value="7">7 Players</option>
                    <option value="8">8 Players</option>
                    <option value="9">9 Players</option>
                    <option value="10">10 Players</option>
                    <option value="15" selected>15 Players</option>
                </select>
            </div>
        </div>
    </div>

    <div class="mode-indicator" id="modeIndicator"></div>
    
    <div class="rugby-widget" id="rugbyPitch">
        <svg class="movement-paths" style="position: absolute; width: 100%; height: 100%; pointer-events: none;">
        </svg>
    </div>

    <div class="timeline" id="timeline">
        <div class="timeline-marker" id="timelineMarker"></div>
    </div>

    <div class="controls">
        <button class="control-btn" id="designBtn" onclick="rugbyDesigner.enterDesignMode()">Design Mode</button>
        <button class="control-btn" onclick="rugbyDesigner.playMovement()">Play</button>
        <button class="control-btn" onclick="rugbyDesigner.pauseMovement()">Pause</button>
        <button class="control-btn" onclick="rugbyDesigner.resetMovement()">Reset</button>
        <button class="control-btn" onclick="rugbyDesigner.clearAll()">Clear All</button>
        <button class="control-btn" onclick="rugbyDesigner.loadSample()">Load Sample</button>
        <button class="control-btn" id="finishPathBtn" onclick="rugbyDesigner.finishPath()" style="display: none; background: #27ae60;">Finish Path</button>
        <button class="control-btn" id="saveBtn">Save Drill</button>
        <input type="file" id="uploadInput" style="display:none" accept=".json">
        <button class="control-btn" id="uploadBtn">Upload Drill</button>
        <button class="control-btn" id="downloadGifBtn">Download GIF</button>
        <span id="gifProgress" style="font-size:12px; margin-left:10px;"></span>
    </div>
    <div class="controls" id="designControlsRow">
        <button class="control-btn" id="addCodeBtn" onclick="rugbyDesigner.toggleAddCodeMode()" style="background: #2196F3; display: none;">Add Cones</button>
        <button class="control-btn" id="hideWaypointBtn" onclick="rugbyDesigner.toggleWaypoints()" style="background: #888; display: none;">Hide Waypoints</button>
        <button class="control-btn" id="lassoBtn" onclick="rugbyDesigner.toggleLassoMode()" style="background: #6c757d; display: none;">Move</button>
    </div>

    <script>
        class RugbyDesigner {
            constructor() {
                this.pitch = document.getElementById('rugbyPitch');
                this.timeline = document.getElementById('timeline');
                this.timelineMarker = document.getElementById('timelineMarker');
                this.modeIndicator = document.getElementById('modeIndicator');
                this.pathsSvg = this.pitch.querySelector('.movement-paths');
                
                this.players = [];
                this.startPositions = [];
                this.waypointMarkers = [];
                this.connections = [];
                this.currentDrill = null;
                this.isPlaying = false;
                this.isDesignMode = false; // Start in play mode
                this.currentTime = 0;
                this.totalTime = 3000;
                this.animationFrame = null;
                this.selectedPlayer = null;
                this.settingEndPosition = false;
                this.mode = 'drill';
                this.playerCount = 5;
                this.teamACount = 15;
                this.teamBCount = 15;
                this.codes = [];
                this.isAddCodeMode = false;
                this.waypointsHidden = false;
                this.lassoMode = false;
                this.draggedObject = null;
                this.dragOffset = { x: 0, y: 0 };
                
                this.bindEvents();
                this.initPlayers();
                this.setupSaveUpload();
                this.setupGifExport();

                // Set initial mode indicator to blank
                this.modeIndicator.innerHTML = '';
            }

            toggleLassoMode() {
                this.lassoMode = !this.lassoMode;
                document.getElementById('lassoBtn').classList.toggle('active', this.lassoMode);
                document.getElementById('lassoBtn').textContent = this.lassoMode ? 'Exit Move' : 'Move';
                this.updateModeIndicator(this.lassoMode ? 'Move: Drag players to reposition.' : 'Design Mode');
            }

            bindEvents() {
                this.pitch.addEventListener('click', (e) => this.handlePitchClick(e));
                this.pitch.addEventListener('contextmenu', (e) => this.handleRightClick(e));
                this.pitch.addEventListener('dblclick', (e) => this.handleDoubleClick(e));
                this.pitch.addEventListener('click', (e) => this.handleCodeClick(e));
                this.pitch.addEventListener('dblclick', (e) => this.handleCodeDoubleClick(e));
                this.pitch.addEventListener('mousedown', (e) => this.handleLassoDown(e));
                document.addEventListener('mousemove', (e) => this.handleLassoMove(e));
                document.addEventListener('mouseup', (e) => this.handleLassoUp(e));
            }

            setMode(mode) {
                this.mode = mode;
                document.getElementById('drillModeBtn').classList.toggle('active', mode === 'drill');
                document.getElementById('matchModeBtn').classList.toggle('active', mode === 'match');
                document.getElementById('drillSettings').style.display = mode === 'drill' ? 'flex' : 'none';
                document.getElementById('matchSettings').style.display = mode === 'match' ? 'flex' : 'none';
                
                this.clearAllPlayers();
                this.initPlayers();
            }

            updatePlayerCount() {
                if (this.mode !== 'drill') return;
                this.playerCount = parseInt(document.getElementById('playerCount').value);
                this.clearAllPlayers();
                this.initPlayers();
            }

            updateTeamCounts() {
                if (this.mode !== 'match') return;
                this.teamACount = parseInt(document.getElementById('teamACount').value);
                this.teamBCount = parseInt(document.getElementById('teamBCount').value);
                this.clearAllPlayers();
                this.initPlayers();
            }

            clearAllPlayers() {
                this.players.forEach(player => player.remove());
                this.startPositions.forEach(pos => pos.remove());
                this.waypointMarkers.forEach(marker => marker.remove());
                this.connections.forEach(line => line.remove());
                this.players = [];
                this.startPositions = [];
                this.waypointMarkers = [];
                this.connections = [];
                this.selectedPlayer = null;
                this.settingEndPosition = false;
                this.pathsSvg.innerHTML = '';
                this.codes.forEach(code => code.remove());
                this.codes = [];
            }

            initPlayers() {
                if (this.mode === 'drill') {
                    this.initDrillPlayers();
                } else {
                    this.initMatchPlayers();
                }
                this.drawConnections();
                this.updateModeDisplay();
            }

            initDrillPlayers() {
                const spacing = Math.min(60, 600 / this.playerCount);
                const startX = 100 + (600 - (this.playerCount - 1) * spacing) / 2;
                
                for (let i = 0; i < this.playerCount; i++) {
                    this.createPlayer(startX + i * spacing, 200, 'team-a', i + 1);
                }
            }

            initMatchPlayers() {
                const teamASpacing = Math.min(40, 350 / this.teamACount);
                const teamAStartY = 200 - (this.teamACount - 1) * teamASpacing / 2;
                
                for (let i = 0; i < this.teamACount; i++) {
                    this.createPlayer(150, teamAStartY + i * teamASpacing, 'team-a', i + 1);
                }
                
                const teamBSpacing = Math.min(40, 350 / this.teamBCount);
                const teamBStartY = 200 - (this.teamBCount - 1) * teamBSpacing / 2;
                
                for (let i = 0; i < this.teamBCount; i++) {
                    this.createPlayer(650, teamBStartY + i * teamBSpacing, 'team-b', i + 1);
                }
            }

            createPlayer(x, y, team, number) {
                const player = document.createElement('div');
                player.className = `player ${team}`;
                player.style.left = x + 'px';
                player.style.top = y + 'px';
                player.textContent = number;
                player.dataset.startX = x;
                player.dataset.startY = y;
                player.dataset.endX = x;
                player.dataset.endY = y;
                player.dataset.team = team;
                player.dataset.number = number;
                
                this.pitch.appendChild(player);
                this.players.push(player);
                
                const startPos = document.createElement('div');
                startPos.className = 'start-position';
                startPos.style.left = (x + 2) + 'px';
                startPos.style.top = (y + 2) + 'px';
                this.pitch.appendChild(startPos);
                this.startPositions.push(startPos);
            }

            updateModeDisplay() {
                if (this.isDesignMode) {
                    const modeText = this.mode === 'drill'
                        ? `DESIGN MODE (${this.playerCount} players): Click on a player to start creating their movement path`
                        : `DESIGN MODE (Team A: ${this.teamACount}, Team B: ${this.teamBCount}): Click on a player to start creating their movement path`;
                    this.modeIndicator.innerHTML = `<strong>${modeText}</strong>`;
                    this.modeIndicator.className = 'mode-indicator design-mode';
                } else {
                    // Blank in play mode
                    this.modeIndicator.innerHTML = '';
                    this.modeIndicator.className = 'mode-indicator play-mode';
                }
            }

            updateModeIndicator(text) {
                this.modeIndicator.innerHTML = `<strong>${text}</strong>`;
            }

            handlePitchClick(e) {
                if (!this.isDesignMode || this.isPlaying) return;
                
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const clickedPlayer = this.getPlayerAt(x, y);
                const clickedWaypoint = this.getWaypointAt(x, y);
                
                if (clickedPlayer && !this.settingEndPosition) {
                    // Start creating a path for this player
                    this.selectPlayer(clickedPlayer);
                    this.settingEndPosition = true;
                    if (!this.selectedPlayer.waypoints) {
                        this.selectedPlayer.waypoints = [];
                    }
                    this.showPathCreationMode();
                } else if (this.settingEndPosition && this.selectedPlayer && !clickedPlayer && !clickedWaypoint) {
                    // Add waypoint (only if we didn't click on a player or existing waypoint)
                    this.addWaypoint(this.selectedPlayer, x, y);
                    this.updateWaypointMarkers();
                    this.drawPaths();
                }
            }

            handleDoubleClick(e) {
                if (!this.isDesignMode || this.isPlaying) return;
                
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const clickedWaypoint = this.getWaypointAt(x, y);
                if (clickedWaypoint) {
                    this.deleteWaypoint(clickedWaypoint);
                }
            }

            getWaypointAt(x, y) {
                return this.waypointMarkers.find(marker => {
                    const mx = parseInt(marker.style.left);
                    const my = parseInt(marker.style.top);
                    const distance = Math.sqrt((x - mx - 8) ** 2 + (y - my - 8) ** 2);
                    return distance < 12;
                });
            }

            showPathCreationMode() {
                const playerNum = this.selectedPlayer.dataset.number;
                const teamColor = this.selectedPlayer.dataset.team === 'team-a' ? 'Red' : 'Blue';
                
                this.modeIndicator.innerHTML = `
                    <strong>CREATING PATH for Player ${playerNum} (${teamColor})</strong><br>
                    Click on the field to add waypoints. Click "Finish Path" button when done.
                `;
                this.modeIndicator.className = 'mode-indicator creating-path';
                
                // Show the finish path button
                document.getElementById('finishPathBtn').style.display = 'inline-block';
            }

            getPlayerAt(x, y) {
                return this.players.find(player => {
                    const px = parseInt(player.style.left);
                    const py = parseInt(player.style.top);
                    const distance = Math.sqrt((x - px - 6) ** 2 + (y - py - 6) ** 2);
                    return distance < 15;
                });
            }

            selectPlayer(player) {
                if (this.selectedPlayer) {
                    this.selectedPlayer.classList.remove('selected');
                }
                this.selectedPlayer = player;
                player.classList.add('selected');
            }

            setPlayerEndPosition(player, x, y) {
                player.dataset.endX = x - 6;
                player.dataset.endY = y - 6;
            }

            addWaypoint(player, x, y) {
                if (!player.waypoints) {
                    player.waypoints = [];
                }
                const waypointData = { x: x - 6, y: y - 6, player: player };
                player.waypoints.push(waypointData);
                
                // Update end position to the latest waypoint
                player.dataset.endX = x - 6;
                player.dataset.endY = y - 6;
                
                const playerNum = player.dataset.number;
                const teamColor = player.dataset.team === 'team-a' ? 'Red' : 'Blue';
                
                this.modeIndicator.innerHTML = `
                    <strong>CREATING PATH for Player ${playerNum} (${teamColor})</strong><br>
                    Waypoint ${player.waypoints.length} added! Continue clicking to add more waypoints, or click "Finish Path" when done.<br>
                    <small>Double-click any blue waypoint to delete it</small>
                `;
            }

            updateWaypointMarkers() {
                // Clear existing waypoint markers
                this.waypointMarkers.forEach(marker => marker.remove());
                this.waypointMarkers = [];
                
                // Create new waypoint markers for all players
                this.players.forEach(player => {
                    if (player.waypoints && player.waypoints.length > 0) {
                        player.waypoints.forEach((waypoint, index) => {
                            this.createWaypointMarker(waypoint, index + 1, player);
                        });
                    }
                });
            }

            createWaypointMarker(waypoint, number, player) {
                const marker = document.createElement('div');
                marker.className = 'waypoint-marker';
                marker.style.left = (waypoint.x + 6 - 8) + 'px'; // Center the marker
                marker.style.top = (waypoint.y + 6 - 8) + 'px';   // Center the marker
                marker.textContent = number;
                marker.dataset.player = player.dataset.number;
                marker.dataset.team = player.dataset.team;
                marker.dataset.waypointIndex = number - 1;
                
                // Store reference to waypoint data
                marker.waypointData = waypoint;
                marker.ownerPlayer = player;
                
                this.pitch.appendChild(marker);
                this.waypointMarkers.push(marker);
            }

            deleteWaypoint(waypointMarker) {
                const player = waypointMarker.ownerPlayer;
                const waypointIndex = parseInt(waypointMarker.dataset.waypointIndex);
                
                // Remove waypoint from player's waypoints array
                player.waypoints.splice(waypointIndex, 1);
                
                // Update end position
                if (player.waypoints.length > 0) {
                    const lastWaypoint = player.waypoints[player.waypoints.length - 1];
                    player.dataset.endX = lastWaypoint.x;
                    player.dataset.endY = lastWaypoint.y;
                } else {
                    // No waypoints left, reset to start position
                    player.dataset.endX = player.dataset.startX;
                    player.dataset.endY = player.dataset.startY;
                }
                
                // Update display
                this.updateWaypointMarkers();
                this.drawPaths();
                
                // Update status message if we're currently editing this player
                if (this.selectedPlayer === player) {
                    const playerNum = player.dataset.number;
                    const teamColor = player.dataset.team === 'team-a' ? 'Red' : 'Blue';
                    this.modeIndicator.innerHTML = `
                        <strong>CREATING PATH for Player ${playerNum} (${teamColor})</strong><br>
                        Waypoint deleted! ${player.waypoints.length} waypoints remaining. Continue clicking to add more waypoints.<br>
                        <small>Double-click any blue waypoint to delete it</small>
                    `;
                }
            }

            handleRightClick(e) {
                e.preventDefault();
                if (this.settingEndPosition && this.selectedPlayer) {
                    this.finishPath();
                }
            }

            finishPath() {
                if (this.selectedPlayer) {
                    this.settingEndPosition = false;
                    this.selectedPlayer.classList.remove('selected');
                    this.selectedPlayer = null;
                    
                    // Hide the finish path button
                    document.getElementById('finishPathBtn').style.display = 'none';
                    
                    // Make sure waypoint markers are updated
                    this.updateWaypointMarkers();
                    this.updateModeDisplay();
                    this.drawConnections();
                    this.drawPaths();
                }
            }

            drawConnections() {
                this.connections.forEach(line => line.remove());
                this.connections = [];

                if (this.mode === 'drill') {
                    for (let i = 0; i < this.players.length - 1; i++) {
                        const player1 = this.players[i];
                        const player2 = this.players[i + 1];
                        this.createConnection(player1, player2);
                    }
                } else {
                    const teamAPlayers = this.players.filter(p => p.dataset.team === 'team-a');
                    const teamBPlayers = this.players.filter(p => p.dataset.team === 'team-b');
                    
                    for (let i = 0; i < teamAPlayers.length - 1; i++) {
                        this.createConnection(teamAPlayers[i], teamAPlayers[i + 1]);
                    }
                    
                    for (let i = 0; i < teamBPlayers.length - 1; i++) {
                        this.createConnection(teamBPlayers[i], teamBPlayers[i + 1]);
                    }
                }
            }

            createConnection(player1, player2) {
                const x1 = parseInt(player1.style.left) + 6;
                const y1 = parseInt(player1.style.top) + 6;
                const x2 = parseInt(player2.style.left) + 6;
                const y2 = parseInt(player2.style.top) + 6;
                
                const line = document.createElement('div');
                line.className = 'connection-line';
                
                const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                line.style.left = x1 + 'px';
                line.style.top = y1 + 'px';
                line.style.width = length + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                
                this.pitch.appendChild(line);
                this.connections.push(line);
            }

            drawPaths() {
                this.pathsSvg.innerHTML = '';
                
                this.players.forEach(player => {
                    const startX = parseInt(player.dataset.startX) + 6;
                    const startY = parseInt(player.dataset.startY) + 6;
                    
                    // Get all path points
                    const pathPoints = [{ x: startX, y: startY }];
                    
                    if (player.waypoints && player.waypoints.length > 0) {
                        player.waypoints.forEach(waypoint => {
                            pathPoints.push({ x: waypoint.x + 6, y: waypoint.y + 6 });
                        });
                    } else {
                        const endX = parseInt(player.dataset.endX) + 6;
                        const endY = parseInt(player.dataset.endY) + 6;
                        if (startX !== endX || startY !== endY) {
                            pathPoints.push({ x: endX, y: endY });
                        }
                    }
                    
                    // Draw path lines
                    if (pathPoints.length > 1) {
                        for (let i = 0; i < pathPoints.length - 1; i++) {
                            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            const d = `M ${pathPoints[i].x} ${pathPoints[i].y} L ${pathPoints[i + 1].x} ${pathPoints[i + 1].y}`;
                            path.setAttribute('d', d);
                            path.setAttribute('class', 'movement-path');
                            
                            if (this.mode === 'match') {
                                const color = player.dataset.team === 'team-a' ? 'rgba(231,76,60,0.5)' : 'rgba(52,152,219,0.5)';
                                path.setAttribute('stroke', color);
                            }
                            
                            this.pathsSvg.appendChild(path);
                        }
                        
                        // Draw direction arrows
                        for (let i = 0; i < pathPoints.length - 1; i++) {
                            this.drawArrow(pathPoints[i], pathPoints[i + 1], player.dataset.team);
                        }
                    }
                });
            }

            drawArrow(startPoint, endPoint, team) {
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length < 20) return; // Skip arrows for very short segments
                
                // Calculate arrow position (midpoint of segment)
                const arrowX = startPoint.x + dx * 0.6;
                const arrowY = startPoint.y + dy * 0.6;
                
                // Calculate arrow angle
                const angle = Math.atan2(dy, dx);
                
                // Arrow size
                const arrowSize = 8;
                
                // Calculate arrow points
                const arrowPoint1X = arrowX - arrowSize * Math.cos(angle - Math.PI / 6);
                const arrowPoint1Y = arrowY - arrowSize * Math.sin(angle - Math.PI / 6);
                const arrowPoint2X = arrowX - arrowSize * Math.cos(angle + Math.PI / 6);
                const arrowPoint2Y = arrowY - arrowSize * Math.sin(angle + Math.PI / 6);
                
                // Create arrow
                const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                const points = `${arrowX},${arrowY} ${arrowPoint1X},${arrowPoint1Y} ${arrowPoint2X},${arrowPoint2Y}`;
                arrow.setAttribute('points', points);
                
                const color = this.mode === 'match' 
                    ? (team === 'team-a' ? '#e74c3c' : '#3498db')
                    : '#333';
                
                arrow.setAttribute('fill', color);
                arrow.setAttribute('stroke', 'white');
                arrow.setAttribute('stroke-width', '0.5');
                
                this.pathsSvg.appendChild(arrow);
            }

            enterDesignMode() {
                // Toggle design mode state
                this.isDesignMode = !this.isDesignMode;

                if (this.isDesignMode) {
                    // Enter design mode
                    this.pauseMovement();
                    this.resetMovement();
                    this.pitch.classList.remove('playing');
                    document.getElementById('designBtn').classList.add('active');
                    document.getElementById('addCodeBtn').style.display = 'inline-block';
                    document.getElementById('hideWaypointBtn').style.display = 'inline-block';
                    document.getElementById('lassoBtn').style.display = 'inline-block';
                    this.setWaypointsVisible(!this.waypointsHidden);

                    // Set main control buttons to dark grey
                    const mainBtns = document.querySelectorAll('.controls:not(#designControlsRow) .control-btn');
                    mainBtns.forEach(btn => {
                        btn.style.background = '#333';
                        btn.style.color = 'white';
                    });

                    // Set design-only buttons to light grey
                    document.getElementById('addCodeBtn').style.background = '#e0e0e0';
                    document.getElementById('addCodeBtn').style.color = '#333';
                    document.getElementById('hideWaypointBtn').style.background = '#e0e0e0';
                    document.getElementById('hideWaypointBtn').style.color = '#333';
                    document.getElementById('lassoBtn').style.background = '#e0e0e0';
                    document.getElementById('lassoBtn').style.color = '#333';

                    this.updateModeDisplay(); // <-- Always call this here
                } else {
                    // Enter play mode
                    this.settingEndPosition = false;
                    if (this.selectedPlayer) {
                        this.selectedPlayer.classList.remove('selected');
                        this.selectedPlayer = null;
                    }
                    this.pitch.classList.add('playing');
                    document.getElementById('designBtn').classList.remove('active');
                    document.getElementById('addCodeBtn').style.display = 'none';
                    document.getElementById('hideWaypointBtn').style.display = 'none';
                    document.getElementById('lassoBtn').style.display = 'none';

                    this.updateModeDisplay(); // <-- Always call this here
                }
            }

            playMovement() {
                if (!this.isDesignMode) {
                    if (this.isPlaying) return;
                    this.generateCurrentDrill(); // <-- Add this line
                    this.isPlaying = true;
                    this.animateMovement();
                } else {
                    this.enterPlayMode();
                    setTimeout(() => this.playMovement(), 100);
                }
            }

            enterPlayMode() {
                this.isDesignMode = false;
                this.settingEndPosition = false;
                if (this.selectedPlayer) {
                    this.selectedPlayer.classList.remove('selected');
                    this.selectedPlayer = null;
                }
                this.pitch.classList.add('playing');
                document.getElementById('hideWaypointBtn').style.display = 'none';
                document.getElementById('lassoBtn').style.display = 'none';
                this.updateModeIndicator(this.mode === 'drill' ? 'PLAYING DRILL' : 'PLAYING MATCH');
            }

            generateCurrentDrill() {
                const movements = this.players.map(player => {
                    const startX = parseInt(player.dataset.startX);
                    const startY = parseInt(player.dataset.startY);
                    
                    // Build complete path including waypoints
                    const pathPoints = [{ x: startX, y: startY }];
                    
                    if (player.waypoints && player.waypoints.length > 0) {
                        player.waypoints.forEach(waypoint => {
                            pathPoints.push({ x: waypoint.x, y: waypoint.y });
                        });
                    } else {
                        const endX = parseInt(player.dataset.endX);
                        const endY = parseInt(player.dataset.endY);
                        if (startX !== endX || startY !== endY) {
                            pathPoints.push({ x: endX, y: endY });
                        }
                    }
                    
                    // Calculate total distance for constant speed
                    let totalDistance = 0;
                    for (let i = 0; i < pathPoints.length - 1; i++) {
                        const dx = pathPoints[i + 1].x - pathPoints[i].x;
                        const dy = pathPoints[i + 1].y - pathPoints[i].y;
                        totalDistance += Math.sqrt(dx * dx + dy * dy);
                    }
                    
                    return {
                        pathPoints,
                        totalDistance,
                        startX,
                        startY
                    };
                });

                this.currentDrill = { movements, totalTime: this.totalTime };
            }

            animateMovement() {
                const startTime = Date.now();
                const animate = () => {
                    if (!this.isPlaying) return;
                    
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / this.totalTime, 1);
                    
                    this.players.forEach((player, index) => {
                        const movement = this.currentDrill.movements[index];
                        const position = this.getPositionAlongPath(movement, progress);
                        
                        player.style.left = position.x + 'px';
                        player.style.top = position.y + 'px';
                    });
                    
                    this.timelineMarker.style.left = (progress * (this.timeline.offsetWidth - 2)) + 'px';
                    
                    if (progress < 1) {
                        this.animationFrame = requestAnimationFrame(animate);
                    } else {
                        this.isPlaying = false;
                    }
                };
                
                animate();
            }

            getPositionAlongPath(movement, progress) {
                const { pathPoints, totalDistance } = movement;
                
                if (pathPoints.length <= 1) {
                    return { x: pathPoints[0].x, y: pathPoints[0].y };
                }
                
                // Calculate target distance along path
                const targetDistance = totalDistance * progress;
                
                // Find which segment we're on
                let currentDistance = 0;
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const dx = pathPoints[i + 1].x - pathPoints[i].x;
                    const dy = pathPoints[i + 1].y - pathPoints[i].y;
                    const segmentDistance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (currentDistance + segmentDistance >= targetDistance) {
                        // We're on this segment
                        const segmentProgress = (targetDistance - currentDistance) / segmentDistance;
                        
                        return {
                            x: pathPoints[i].x + dx * segmentProgress,
                            y: pathPoints[i].y + dy * segmentProgress
                        };
                    }
                    
                    currentDistance += segmentDistance;
                }
                
                // If we're past the end, return the last point
                return { x: pathPoints[pathPoints.length - 1].x, y: pathPoints[pathPoints.length - 1].y };
            }

            pauseMovement() {
                this.isPlaying = false;
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
            }

            resetMovement() {
                this.pauseMovement();
                this.currentTime = 0;
                this.timelineMarker.style.left = '0px';
                
                this.players.forEach(player => {
                    player.style.left = player.dataset.startX + 'px';
                    player.style.top = player.dataset.startY + 'px';
                });
            }

            clearAll() {
                this.pauseMovement();
                this.resetMovement();
                this.players.forEach(player => {
                    player.dataset.endX = player.dataset.startX;
                    player.dataset.endY = player.dataset.startY;
                    player.waypoints = [];
                });
                this.updateWaypointMarkers();
                this.drawPaths();
                this.enterDesignMode();
                this.codes.forEach(code => code.remove());
                this.codes = [];
            }

            loadSample() {
                this.clearAll();
                
                // Create a sample movement pattern with waypoints
                this.players.forEach((player, index) => {
                    const baseX = parseInt(player.dataset.startX);
                    const baseY = parseInt(player.dataset.startY);
                    
                    // Initialize waypoints array
                    player.waypoints = [];
                    
                    // Create different movement patterns with multiple waypoints
                    if (this.mode === 'drill') {
                        // Create zigzag patterns, cutting moves, and loops
                        if (index % 3 === 0) {
                            // Zigzag pattern
                            player.waypoints.push({ x: baseX + 80, y: baseY - 40 });
                            player.waypoints.push({ x: baseX + 120, y: baseY + 40 });
                            player.waypoints.push({ x: baseX + 180, y: baseY - 20 });
                        } else if (index % 3 === 1) {
                            // Sharp cutting move
                            player.waypoints.push({ x: baseX + 100, y: baseY });
                            player.waypoints.push({ x: baseX + 120, y: baseY - 60 });
                            player.waypoints.push({ x: baseX + 200, y: baseY - 80 });
                        } else {
                            // Loop back pattern
                            player.waypoints.push({ x: baseX + 60, y: baseY + 50 });
                            player.waypoints.push({ x: baseX + 140, y: baseY + 60 });
                            player.waypoints.push({ x: baseX + 160, y: baseY - 30 });
                            player.waypoints.push({ x: baseX + 120, y: baseY - 50 });
                        }
                    } else {
                        // Match scenario movements with tactical patterns
                        if (player.dataset.team === 'team-a') {
                            if (index % 2 === 0) {
                                // Attacking line with dummy and cut
                                player.waypoints.push({ x: baseX + 80, y: baseY + 20 });
                                player.waypoints.push({ x: baseX + 120, y: baseY - 30 });
                                player.waypoints.push({ x: baseX + 200, y: baseY - 40 });
                            } else {
                                // Support run with loop
                                player.waypoints.push({ x: baseX + 60, y: baseY - 40 });
                                player.waypoints.push({ x: baseX + 140, y: baseY - 20 });
                            }
                        } else {
                            if (index % 2 === 0) {
                                // Defensive drift
                                player.waypoints.push({ x: baseX - 60, y: baseY - 20 });
                                player.waypoints.push({ x: baseX - 120, y: baseY - 40 });
                                player.waypoints.push({ x: baseX - 160, y: baseY - 30 });
                            } else {
                                // Counter-attack run
                                player.waypoints.push({ x: baseX - 80, y: baseY + 30 });
                                player.waypoints.push({ x: baseX - 40, y: baseY + 60 });
                                player.waypoints.push({ x: baseX + 40, y: baseY + 40 });
                            }
                        }
                    }
                    
                    // Set end position to last waypoint
                    if (player.waypoints.length > 0) {
                        const lastWaypoint = player.waypoints[player.waypoints.length - 1];
                        player.dataset.endX = lastWaypoint.x;
                        player.dataset.endY = lastWaypoint.y;
                    }
                });
                
                this.drawPaths();
                this.updateModeIndicator('Sample loaded with complex movement patterns! Click Play to see the movements');
            }

            toggleAddCodeMode() {
                this.isAddCodeMode = !this.isAddCodeMode;
                document.getElementById('addCodeBtn').classList.toggle('active', this.isAddCodeMode);
                this.updateModeIndicator(this.isAddCodeMode ? 'Add Code mode: Click on the pitch to add a code. Double-click a code to remove.' : 'Design Mode');
            }

            handleCodeClick(e) {
                if (!this.isAddCodeMode || this.isPlaying || this.mode !== 'drill') return;
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                // Prevent adding code if clicking on a player or waypoint
                if (this.getPlayerAt(x, y) || this.getWaypointAt(x, y)) return;
                if (this.getCodeAt(x, y)) return;
                this.addCode(x, y);
            }

            handleCodeDoubleClick(e) {
                if (!this.isAddCodeMode || this.isPlaying || this.mode !== 'drill') return;
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const code = this.getCodeAt(x, y);
                if (code) {
                    this.removeCode(code);
                }
            }

            addCode(x, y) {
                const code = document.createElement('div');
                code.className = 'code-marker';
                code.style.left = (x - 7) + 'px';
                code.style.top = (y - 7) + 'px';
                this.pitch.appendChild(code);
                this.codes.push(code);
            }

            getCodeAt(x, y) {
                return this.codes.find(code => {
                    const cx = parseInt(code.style.left);
                    const cy = parseInt(code.style.top);
                    const distance = Math.sqrt((x - cx - 7) ** 2 + (y - cy - 7) ** 2);
                    return distance < 10;
                });
            }

            removeCode(code) {
                code.remove();
                this.codes = this.codes.filter(c => c !== code);
            }

            toggleWaypoints() {
                this.waypointsHidden = !this.waypointsHidden;
                this.setWaypointsVisible(!this.waypointsHidden);
                document.getElementById('hideWaypointBtn').textContent = this.waypointsHidden ? 'Show Waypoints' : 'Hide Waypoints';
            }

            setWaypointsVisible(visible) {
                this.waypointMarkers.forEach(marker => {
                    marker.style.display = visible ? 'flex' : 'none';
                });
            }

            handleLassoDown(e) {
                if (!this.lassoMode || this.isPlaying || !this.isDesignMode) return;
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check for player
                const player = this.getPlayerAt(x, y);
                if (player) {
                    this.draggedObject = { type: 'player', obj: player };
                    this.dragOffset.x = x - parseInt(player.style.left);
                    this.dragOffset.y = y - parseInt(player.style.top);
                    e.preventDefault();
                    return;
                }
                // Check for waypoint
                const waypoint = this.getWaypointAt(x, y);
                if (waypoint) {
                    this.draggedObject = { type: 'waypoint', obj: waypoint };
                    this.dragOffset.x = x - parseInt(waypoint.style.left);
                    this.dragOffset.y = y - parseInt(waypoint.style.top);
                    e.preventDefault();
                    return;
                }
                // Check for cone
                const cone = this.getCodeAt(x, y);
                if (cone) {
                    this.draggedObject = { type: 'cone', obj: cone };
                    this.dragOffset.x = x - parseInt(cone.style.left);
                    this.dragOffset.y = y - parseInt(cone.style.top);
                    e.preventDefault();
                    return;
                }
            }

            handleLassoMove(e) {
                if (!this.lassoMode || !this.draggedObject) return;
                const rect = this.pitch.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                if (this.draggedObject.type === 'player') {
                    const player = this.draggedObject.obj;
                    player.style.left = (x - this.dragOffset.x) + 'px';
                    player.style.top = (y - this.dragOffset.y) + 'px';
                    player.dataset.startX = parseInt(player.style.left);
                    player.dataset.startY = parseInt(player.style.top);
                    player.dataset.endX = player.dataset.startX;
                    player.dataset.endY = player.dataset.startY;

                    // Update the corresponding start-position marker
                    const playerIndex = this.players.indexOf(player);
                    if (playerIndex !== -1) {
                        const startPos = this.startPositions[playerIndex];
                        startPos.style.left = (player.dataset.startX + 2) + 'px';
                        startPos.style.top = (player.dataset.startY + 2) + 'px';
                    }

                    this.drawConnections();
                    this.drawPaths();
                } else if (this.draggedObject.type === 'waypoint') {
                    const marker = this.draggedObject.obj;
                    marker.style.left = (x - this.dragOffset.x) + 'px';
                    marker.style.top = (y - this.dragOffset.y) + 'px';
                    // Update waypoint data
                    const waypoint = marker.waypointData;
                    waypoint.x = parseInt(marker.style.left) + 8 - 6; // adjust for marker offset
                    waypoint.y = parseInt(marker.style.top) + 8 - 6;
                    marker.ownerPlayer.dataset.endX = waypoint.x;
                    marker.ownerPlayer.dataset.endY = waypoint.y;
                    this.drawPaths();
                } else if (this.draggedObject.type === 'cone') {
                    const cone = this.draggedObject.obj;
                    cone.style.left = (x - this.dragOffset.x) + 'px';
                    cone.style.top = (y - this.dragOffset.y) + 'px';
                }
            }

            handleLassoUp(e) {
                if (!this.lassoMode) return;
                this.draggedObject = null;
            }

            setupSaveUpload() {
                document.getElementById('saveBtn').onclick = () => this.saveDrill();
                document.getElementById('uploadBtn').onclick = () => document.getElementById('uploadInput').click();
                document.getElementById('uploadInput').onchange = (e) => this.uploadDrill(e);
            }

            setupGifExport() {
                document.getElementById('downloadGifBtn').onclick = () => this.exportGif();
                this.gifProgress = document.getElementById('gifProgress');
            }

            saveDrill() {
                const drillName = prompt("Enter a name for this drill:");
                if (!drillName) return;

                // Gather drill data
                const data = {
                    name: drillName,
                    mode: this.mode,
                    playerCount: this.playerCount,
                    teamACount: this.teamACount,
                    teamBCount: this.teamBCount,
                    players: this.players.map((player, i) => ({
                        team: player.dataset.team,
                        number: player.dataset.number,
                        startX: player.dataset.startX,
                        startY: player.dataset.startY,
                        endX: player.dataset.endX,
                        endY: player.dataset.endY,
                        waypoints: player.waypoints ? player.waypoints.map(wp => ({ x: wp.x, y: wp.y })) : []
                    })),
                    codes: this.codes.map(code => ({
                        left: code.style.left,
                        top: code.style.top
                    }))
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: "application/json" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `${drillName.replace(/\s+/g, '_')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            uploadDrill(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    try {
                        const data = JSON.parse(evt.target.result);
                        this.loadDrillData(data);
                    } catch (err) {
                        alert("Invalid drill file.");
                    }
                };
                reader.readAsText(file);
            }

            exportGif() {
                if (this.isPlaying) {
                    alert("Please pause the animation before exporting.");
                    return;
                }
                this.gifProgress.textContent = "Generating GIF...";

                this.generateCurrentDrill();

                const frames = 40;
                const duration = this.totalTime;
                const frameDelay = Math.round(duration / frames / 10); // gif.js uses delay in 1/100s

                const gif = new window.GIF({
                    workers: 2,
                    quality: 10,
                    width: this.pitch.offsetWidth,
                    height: this.pitch.offsetHeight,
                    workerScript: 'gif.worker.js'
                });

                // Hide overlays for GIF
                const overlays = [this.timeline, this.modeIndicator];
                overlays.forEach(el => el.style.visibility = 'hidden');

                // Helper to capture a frame and add to GIF
                const captureFrame = (progress, cb) => {
                    // Move players to correct positions
                    this.players.forEach((player, idx) => {
                        const movement = this.currentDrill.movements[idx];
                        const pos = this.getPositionAlongPath(movement, progress);
                        player.style.left = pos.x + 'px';
                        player.style.top = pos.y + 'px';
                    });
                    this.timelineMarker.style.left = (progress * (this.timeline.offsetWidth - 2)) + 'px';

                    html2canvas(this.pitch, {
                        scale: 1
                    }).then(canvas => {
                        gif.addFrame(canvas, {delay: frameDelay});
                        cb();
                    });
                };

                let i = 0;
                const nextFrame = () => {
                    if (i > frames) {
                        overlays.forEach(el => el.style.visibility = 'visible');
                        this.gifProgress.textContent = "Rendering GIF...";
                        gif.on('finished', (blob) => {
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'rugby_drill.gif';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            this.gifProgress.textContent = "GIF downloaded!";
                        });
                        gif.render();
                        return;
                    }
                    const progress = i / frames;
                    this.gifProgress.textContent = `Capturing frames... ${i + 1}/${frames + 1}`;
                    captureFrame(progress, () => {
                        i++;
                        setTimeout(nextFrame, 10);
                    });
                };
                nextFrame();
            }

            loadDrillData(data) {
                // Set mode and player counts
                this.setMode(data.mode || 'drill');
                if (data.mode === 'drill') {
                    this.playerCount = data.playerCount || 5;
                    document.getElementById('playerCount').value = this.playerCount;
                } else {
                    this.teamACount = data.teamACount || 15;
                    this.teamBCount = data.teamBCount || 15;
                    document.getElementById('teamACount').value = this.teamACount;
                    document.getElementById('teamBCount').value = this.teamBCount;
                }
                this.clearAllPlayers();

                // Recreate players
                (data.players || []).forEach((pdata, i) => {
                    this.createPlayer(
                        parseInt(pdata.startX),
                        parseInt(pdata.startY),
                        pdata.team,
                        pdata.number
                    );
                    const player = this.players[this.players.length - 1];
                    player.dataset.endX = pdata.endX;
                    player.dataset.endY = pdata.endY;
                    player.waypoints = (pdata.waypoints || []).map(wp => ({ x: wp.x, y: wp.y, player }));
                });

                // Recreate codes
                (data.codes || []).forEach(cdata => {
                    this.addCode(parseInt(cdata.left) + 7, parseInt(cdata.top) + 7);
                });

                this.updateWaypointMarkers();
                this.drawConnections();
                this.drawPaths();
                this.updateModeIndicator(`Loaded drill: ${data.name || 'Unnamed'}`);
            }
        }

        // Initialize the app
        let rugbyDesigner;
        document.addEventListener('DOMContentLoaded', () => {
            rugbyDesigner = new RugbyDesigner();
        });
    </script>
</body>
</html>