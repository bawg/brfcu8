<script>
        // Store calendar state in variables (memory in HTML)
        const today = new Date();
        let currentMonth = today.getMonth();
        let currentYear = today.getFullYear();

        const monthNames = [
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        ];
        
        // Example events data (now with details, location, attendees)
        const calendarEvents = [
            { date: '2025-01-02', time: '6:00 PM - 8:00 PM', type: 'practice', name: 'Practice', location: 'Barnes Rugby Field', details: 'First practice of the year. Focus on passing drills.', attendees: ['Alice', 'Bob', 'Charlie'] },
            { date: '2025-01-05', time: '7:00 PM - 9:00 PM', type: 'practice', name: 'Training', location: 'Barnes Rugby Field', details: 'Skills training session.', attendees: ['Alice', 'David', 'Eve'] },
            { date: '2025-01-08', time: '9:00 AM - 4:00 PM', type: 'festival', name: 'Festival', location: 'Surrey Sports Park', details: 'Annual rugby festival.', attendees: ['Team Barnes', 'Team Surrey'] },
            { date: '2025-01-13', time: '6:30 PM - 8:30 PM', type: 'practice', name: 'Practice', location: 'Barnes Rugby Field', details: 'Defensive drills and positioning.', attendees: ['Bob', 'Charlie', 'Eve'] },
            { date: '2025-01-15', time: '2:00 PM - 4:00 PM', type: 'match', name: 'Championship', location: 'Twickenham Stadium', details: 'Championship match vs Team Richmond.', attendees: ['Full Squad'] },
            { date: '2025-01-20', time: '7:00 PM - 9:00 PM', type: 'practice', name: 'Training', location: 'Barnes Rugby Field', details: 'Tactical training session.', attendees: ['Alice', 'Bob', 'Charlie', 'David', 'Eve'] },
            { date: '2025-01-22', time: '1:00 PM - 5:00 PM', type: 'festival', name: 'Surrey Cup', location: 'Surrey Sports Park', details: 'Surrey Cup Final.', attendees: ['Team Barnes', 'Team Surrey'] },
            { date: '2025-01-27', time: '3:00 PM - 5:00 PM', type: 'practice', name: 'Match Day', location: 'Barnes Rugby Field', details: 'Friendly match.', attendees: ['Full Squad'] },
            { date: '2025-01-29', time: '10:00 AM - 4:00 PM', type: 'festival', name: 'Spring Festival', location: 'Barnes Rugby Field', details: 'Spring rugby festival.', attendees: ['All Teams'] }
        ];
        
        // Static attendee options
        const attendeeOptions = ['manus', 'andy', 'james'];

        // Add this line to fix the error:
        let isEditingAvailability = false;

        // Issues management data
        let issues = [];

        // Add availability to each event (initialize as empty object if not present)
        calendarEvents.forEach(ev => {
            if (!ev.availability) {
                ev.availability = { manus: '', andy: '', james: '' };
            }
        });

        // Pinch-to-zoom functionality for events table
        let tableZoomLevel = 1;
        let isZooming = false;
        let lastDistance = 0;
        const minZoom = 0.5;
        const maxZoom = 2;
        
        // Initialize calendar on page load
        document.addEventListener('DOMContentLoaded', function() {
            currentMonth = today.getMonth();
            currentYear = today.getFullYear();
            updateCalendarTitle();
            renderCalendar();
            renderEventsTable();
            renderDrillsTable();
            document.getElementById('availabilityUser').style.display = 'none';
            document.getElementById('availabilityUserLabel').style.display = 'none';
            document.getElementById('toggleAvailabilityBtn').textContent = '+ Add Availability';
            isEditingAvailability = false;
            
            // Initialize pinch-to-zoom for events table
            initializePinchZoom();
        });
        
        function renderCalendar() {
            const calendarGrid = document.querySelector('.calendar-grid');
            // Remove all day headers and days
            calendarGrid.innerHTML = '';
            // Add day headers
            ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].forEach(day => {
                const header = document.createElement('div');
                header.className = 'calendar-day-header';
                header.textContent = day;
                calendarGrid.appendChild(header);
            });

            // Get first day of month and number of days
            const firstDay = new Date(currentYear, currentMonth, 1);
            const startDay = firstDay.getDay();
            const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();

            // Previous month's last few days (optional, for full grid)
            const prevMonthDays = startDay;
            const prevMonth = currentMonth === 0 ? 11 : currentMonth - 1;
            const prevMonthYear = currentMonth === 0 ? currentYear - 1 : currentYear;
            const prevMonthLastDay = new Date(prevMonthYear, prevMonth + 1, 0).getDate();

            for (let i = prevMonthLastDay - prevMonthDays + 1; i <= prevMonthLastDay; i++) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day other-month';
                dayDiv.innerHTML = `<div class="day-number">${i}</div>`;
                calendarGrid.appendChild(dayDiv);
            }

            // Current month days
            for (let d = 1; d <= daysInMonth; d++) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day';
                const dateStr = `${currentYear}-${String(currentMonth+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`;
                // Highlight today
                if (
                    d === today.getDate() &&
                    currentYear === today.getFullYear()
                ) {
                    dayDiv.classList.add('today');
                }
                dayDiv.innerHTML = `<div class="day-number${dayDiv.classList.contains('today') ? ' today' : ''}">${d}</div>`;

                // Add events for this day
                const eventList = calendarEvents.filter(ev => ev.date === `${currentYear}-${String(currentMonth+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`);
                eventList.forEach(ev => {
                    const eventDiv = document.createElement('div');
                    eventDiv.className = `event ${ev.type}`;
                    eventDiv.innerHTML = `${ev.name}`;
                    // Add click event to open details (stubbed for now)
                    eventDiv.onclick = function() {
                        openEventDetails(ev);
                    };
                    dayDiv.appendChild(eventDiv);
                });

                calendarGrid.appendChild(dayDiv);
            }
        }
        
        function updateCalendarTitle() {
            const title = document.getElementById('calendar-title');
            title.innerHTML = `${monthNames[currentMonth]} ${currentYear}`;
        }
        
        function changeMonth(delta) {
            currentMonth += delta;
            if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            } else if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
            }
            updateCalendarTitle();
            renderCalendar();
        }
        
        function goToToday() {
            currentMonth = today.getMonth();
            currentYear = today.getFullYear();
            updateCalendarTitle();
            renderCalendar();
        }
        
        function showSection(section) {
            // Hide all sections
            document.querySelectorAll('.mockup-section').forEach(sec => {
                sec.classList.remove('active');
            });
            // Remove active class from all buttons
            document.querySelectorAll('.mockup-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            // Show the selected section
            document.getElementById(section).classList.add('active');
            // Add active class to the corresponding button
            document.querySelector(`.mockup-btn[onclick="showSection('${section}')"]`).classList.add('active');
        }
        window.showSection = showSection;

        function renderEventsTable() {
            const tableBody = document.getElementById('events-table-body');
            tableBody.innerHTML = '';

            let filteredEvents = calendarEvents;

            // Apply column filter if set
            if (columnFilter.key && columnFilter.value) {
                filteredEvents = filteredEvents.filter(ev => {
                    let val = '';
                    switch (columnFilter.key) {
                        case 'name': val = ev.name; break;
                        case 'location': val = ev.location; break;
                        case 'date': val = ev.date; break;
                        case 'time': val = ev.time; break;
                        case 'type': val = ev.type; break;
                        case 'availability': val = Object.values(ev.availability).join(','); break;
                    }
                    return val && val.toLowerCase().includes(columnFilter.value);
                });
            }

            // Pagination
            const startIdx = (eventsPage - 1) * eventsPageSize;
            const endIdx = startIdx + eventsPageSize;
            const pagedEvents = filteredEvents.slice(startIdx, endIdx);

            pagedEvents.forEach((ev, idx) => {
                const attending = Object.entries(ev.availability)
                    .filter(([user, val]) => val === 'yes')
                    .map(([user]) => user.charAt(0).toUpperCase() + user.slice(1));
                const availabilityCell = attending.length ? attending.join(', ') : '<span style="color:#64748b;">No one attending</span>';

                // Find the actual index in calendarEvents array
                const actualEventIndex = calendarEvents.findIndex(event => 
                    event.name === ev.name && event.date === ev.date && event.time === ev.time
                );

                const row = document.createElement('div');
                row.className = 'table-row';
                row.innerHTML = `
                    <div>
                        <div class="event-title">${ev.name}</div>
                    </div>
                    <div>${ev.location || ''}</div>
                    <div>${new Date(ev.date).toLocaleDateString()}</div>
                    <div>${ev.time}</div>
                    <div><span class="event-type-badge ${ev.type}">${ev.type.charAt(0).toUpperCase() + ev.type.slice(1)}</span></div>
                    <div>${availabilityCell}</div>
                    <div>
                        <button class="action-btn edit-btn" onclick="editCalendarEvent(${actualEventIndex})">Edit</button>
                    </div>
                `;
                tableBody.appendChild(row);
            });

            // Add pagination controls if needed
            const totalPages = Math.ceil(filteredEvents.length / eventsPageSize);
            if (totalPages > 1) {
                const paginationDiv = document.createElement('div');
                paginationDiv.innerHTML = `
                    <span style="font-weight:500;">Page ${eventsPage} of ${totalPages}</span>
                    <button class="filter-btn" ${eventsPage === totalPages ? 'disabled' : ''} onclick="eventsPage++; renderEventsTable();">Next</button>
                    <button class="filter-btn" onclick="clearColumnFilter()">Clear Filter</button>
                `;
                tableBody.appendChild(paginationDiv);
            }

            // Re-apply zoom after rendering
            setTimeout(() => {
                const eventsTableContainer = document.querySelector('.events-list-container .table-container');
                if (eventsTableContainer && tableZoomLevel !== 1) {
                    const header = eventsTableContainer.querySelector('.table-header');
                    const rows = eventsTableContainer.querySelectorAll('.table-row');
                    
                    if (header) {
                        header.style.fontSize = (14 * tableZoomLevel) + 'px';
                        header.style.padding = Math.max(8, 16 * tableZoomLevel) + 'px 20px';
                    }
                    
                    rows.forEach(row => {
                        const eventTitle = row.querySelector('.event-title');
                        const otherCells = row.querySelectorAll('div:not(.event-title)');
                        
                        if (eventTitle) {
                            eventTitle.style.fontSize = (15 * tableZoomLevel) + 'px';
                        }
                        
                        otherCells.forEach(cell => {
                            cell.style.fontSize = (14 * tableZoomLevel) + 'px';
                        });
                        
                        const badges = row.querySelectorAll('.event-type-badge');
                        badges.forEach(badge => {
                            badge.style.fontSize = (12 * tableZoomLevel) + 'px';
                        });
                        
                        row.style.padding = Math.max(8, 16 * tableZoomLevel) + 'px 20px';
                    });
                }
            }, 10);
        }
        
        function toggleAvailability(eventIdx, user, checked) {
            calendarEvents[eventIdx].availability[user] = checked ? 'yes' : '';
            renderEventsTable();
            renderCalendar();
        }

        function toggleDrillForm() {
            const form = document.getElementById('drill-form');
            if (form.style.display === 'none' || form.style.display === '') {
                form.style.display = 'block';
            } else {
                form.style.display = 'none';
            }
        }
        
        function addDrillToRepository() {
            // Get form values
            const name = document.getElementById('drill-name').value;
            const skill = document.getElementById('drill-skill').value;
            const duration = document.getElementById('drill-duration').value;
            const description = document.getElementById('drill-description').value;
            
            // Basic validation
            if (!name || !skill || !duration || !description) {
                alert('Please fill in all required fields.');
                return;
            }
            
            // Create new drill object
            const newDrill = {
                name,
                skill,
                duration,
                description,
                id: Date.now() // Simple unique id
            };
            
            // Add to drills array
            drills.push(newDrill);
            
            // Show success message
            const successMessage = document.getElementById('drill-success');
            successMessage.style.display = 'block';
            setTimeout(() => {
                successMessage.style.display = 'none';
            }, 3000);
            
            // Reset form
            document.getElementById('drill-name').value = '';
            document.getElementById('drill-skill').value = '';
            document.getElementById('drill-duration').value = '';
            document.getElementById('drill-description').value = '';
            
            // Re-render drills table
            renderDrillsTable();

            // Hide the add drill form
            toggleDrillForm();
        }
        
        function renderDrillsTable() {
            const tableBody = document.getElementById('drills-table-body');
            tableBody.innerHTML = '';
            drills.forEach(drill => {
                const row = document.createElement('div');
                row.className = 'table-row';
                row.setAttribute('data-skill', drill.skill);
                row.setAttribute('data-duration', drill.duration);
                row.innerHTML = `
                    <div>
                        <span class="drill-name">${drill.name}</span>
                        <div class="drill-description">${drill.description}</div>
                    </div>
                    <div><span class="skill-badge skill-${drill.skill.toLowerCase()}">${drill.skill}</span></div>
                    <div><span class="duration-badge">${drill.duration}</span></div>
                    <div class="drill-actions">
                        <button class="action-btn edit-btn" onclick="editDrill(${drill.id})">Edit</button>
                        <button class="action-btn delete-btn" onclick="confirmDeleteDrill(${drill.id})">Delete</button>
                    </div>
                `;
                tableBody.appendChild(row);
            });
        }
        
        function filterDrills() {
            const query = document.querySelector('.search-box').value.toLowerCase();
            const rows = document.querySelectorAll('.table-row');
            rows.forEach(row => {
                const name = row.querySelector('.drill-name').innerText.toLowerCase();
                const description = row.querySelector('.drill-description').innerText.toLowerCase();
                if (name.includes(query) || description.includes(query)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }
        
        function filterBySkill(skill) {
            const rows = document.querySelectorAll('.table-row');
            rows.forEach(row => {
                if (skill === 'all') {
                    row.style.display = '';
                } else {
                    const rowSkill = row.getAttribute('data-skill');
                    if (rowSkill === skill) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                }
            });
        }
        
        function filterByDuration(duration) {
            const rows = document.querySelectorAll('.table-row');
            rows.forEach(row => {
                if (duration === 'all') {
                    row.style.display = '';
                } else {
                    const rowDuration = row.getAttribute('data-duration');
                    if (rowDuration === duration) {
                        row.style.display = '';
                    } else {
                        row.style.display = 'none';
                    }
                }
            });
        }

        // Re-render table when user changes
        document.getElementById('availabilityUser').addEventListener('change', renderEventsTable);

        // Add this near the top of your <script> section, before using drills
        const drills = [
            {
                name: "Passing Drill",
                skill: "Passing",
                duration: "30 minutes",
                description: "Improve passing accuracy and speed.",
                id: 1
            },
            {
                name: "Defensive Line Drill",
                skill: "Defense",
                duration: "45 minutes",
                description: "Work on defensive line structure and communication.",
                id: 2
            },
            {
                name: "Awareness Game",
                skill: "Awareness",
                duration: "15 minutes",
                description: "Enhance spatial awareness with small-sided games.",
                id: 3
            },
            {
                name: "Long Passing",
                skill: "Passing",
                duration: "60 minutes",
                description: "Focus on long-range passing under pressure.",
                id: 4
            },
            {
                name: "Tackle Technique",
                skill: "Defense",
                duration: "30 minutes",
                description: "Refine tackle technique and safety.",
                id: 5
            },
            {
                name: "Vision Drill",
                skill: "Awareness",
                duration: "45 minutes",
                description: "Develop vision and decision-making skills.",
                id: 6
            },
            {
                name: "Quick Hands",
                skill: "Passing",
                duration: "15 minutes",
                description: "Increase hand speed and reaction time.",
                id: 7
            }
        ];

        let eventsPageSize = 10;
        let eventsPage = 1;
        let columnFilter = { key: '', value: '' };
        
        // User role simulation (in a real app this would come from authentication)
        let currentUserRole = 'admin'; // or 'user'
        
        // Variables for confirmation modal
        let confirmationAction = null;
        let currentEditingDrillId = null;
        let currentEditingEventIndex = null;

        // Drill management functions
        function downloadAllDrills() {
            const drillsData = {
                version: "1.0",
                exported: new Date().toISOString(),
                drills: drills
            };
            
            const json = JSON.stringify(drillsData, null, 2);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `drills_export_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showUploadStatus('success', `Downloaded ${drills.length} drills to JSON file.`);
        }

        function uploadDrills(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    let importedDrills = data.drills || data; // Handle both wrapped and direct array formats
                    
                    if (!Array.isArray(importedDrills)) {
                        throw new Error('Invalid file format: expected array of drills');
                    }
                    
                    // Validate drill structure
                    const requiredFields = ['name', 'skill', 'duration', 'description'];
                    for (let drill of importedDrills) {
                        for (let field of requiredFields) {
                            if (!drill[field]) {
                                throw new Error(`Invalid drill structure: missing field '${field}'`);
                            }
                        }
                    }
                    
                    // Show confirmation modal for import options
                    showImportConfirmation(importedDrills);
                    
                } catch (error) {
                    showUploadStatus('error', `Error reading file: ${error.message}`);
                }
            };
            reader.readAsText(file);
        }

        function showImportConfirmation(importedDrills) {
            const existingCount = drills.length;
            const importCount = importedDrills.length;
            
            document.getElementById('modalIcon').textContent = '📤';
            document.getElementById('modalTitle').textContent = 'Import Drills';
            document.getElementById('modalMessage').innerHTML = `
                <p>Found ${importCount} drills to import.</p>
                <p>Current repository contains ${existingCount} drills.</p>
                <p><strong>Choose import mode:</strong></p>
                <div style="margin-top: 12px;">
                    <label style="display: block; margin-bottom: 8px;">
                        <input type="radio" name="importMode" value="append" checked> 
                        <strong>Append:</strong> Add new drills to existing ones
                    </label>
                    <label style="display: block; margin-bottom: 8px;">
                        <input type="radio" name="importMode" value="update"> 
                        <strong>Update:</strong> Replace drills with matching names
                    </label>
                    <label style="display: block;">
                        <input type="radio" name="importMode" value="replace"> 
                        <strong>Replace All:</strong> Delete existing and import new drills
                    </label>
                </div>
            `;
            
            const confirmButton = document.getElementById('confirmButton');
            confirmButton.textContent = 'Import';
            confirmButton.className = 'modal-btn primary';
            
            confirmationAction = () => {
                const mode = document.querySelector('input[name="importMode"]:checked').value;
                processImport(importedDrills, mode);
            };
            
            showConfirmationModal();
        }

        function processImport(importedDrills, mode) {
            let added = 0, updated = 0, replaced = 0;
            
            try {
                switch (mode) {
                    case 'append':
                        importedDrills.forEach(drill => {
                            drill.id = Date.now() + Math.random(); // Ensure unique ID
                            drills.push(drill);
                            added++;
                        });
                        break;
                        
                    case 'update':
                        importedDrills.forEach(importDrill => {
                            const existingIndex = drills.findIndex(d => d.name === importDrill.name);
                            if (existingIndex >= 0) {
                                importDrill.id = drills[existingIndex].id; // Keep existing ID
                                drills[existingIndex] = importDrill;
                                updated++;
                            } else {
                                importDrill.id = Date.now() + Math.random();
                                drills.push(importDrill);
                                added++;
                            }
                        });
                        break;
                        
                    case 'replace':
                        drills.length = 0; // Clear existing drills
                        importedDrills.forEach(drill => {
                            drill.id = Date.now() + Math.random();
                            drills.push(drill);
                            replaced++;
                        });
                        break;
                }
                
                renderDrillsTable();
                
                let message = '';
                if (mode === 'replace') {
                    message = `Replaced all drills with ${replaced} imported drills.`;
                } else {
                    message = `Import complete: ${added} added, ${updated} updated.`;
                }
                showUploadStatus('success', message);
                
            } catch (error) {
                showUploadStatus('error', `Error importing drills: ${error.message}`);
            }
        }

        function showUploadStatus(type, message) {
            // Update both status divs if they exist
            const statusDiv = document.getElementById('upload-status');
            const systemStatusDiv = document.getElementById('upload-status-system');
            
            [statusDiv, systemStatusDiv].forEach(div => {
                if (div) {
                    div.className = `upload-status ${type}`;
                    div.textContent = message;
                    div.style.display = 'block';
                }
            });
            
            setTimeout(() => {
                [statusDiv, systemStatusDiv].forEach(div => {
                    if (div) {
                        div.style.display = 'none';
                    }
                });
            }, 5000);
        }

        function confirmDeleteAllDrills() {
            if (currentUserRole !== 'admin') {
                showUploadStatus('error', 'Only administrators can delete all drills.');
                return;
            }
            
            document.getElementById('modalIcon').textContent = '🗑️';
            document.getElementById('modalTitle').textContent = 'Delete All Drills';
            document.getElementById('modalMessage').innerHTML = `
                <p><strong>⚠️ WARNING: This action cannot be undone!</strong></p>
                <p>This will permanently delete all ${drills.length} drills in the repository.</p>
                <p>Consider downloading a backup first.</p>
            `;
            
            const confirmButton = document.getElementById('confirmButton');
            confirmButton.textContent = 'Delete All';
            confirmButton.className = 'modal-btn confirm';
            
            confirmationAction = () => {
                drills.length = 0; // Clear all drills
                renderDrillsTable();
                showUploadStatus('success', 'All drills have been deleted.');
            };
            
            showConfirmationModal();
        }

        function editDrill(drillId) {
            const drill = drills.find(d => d.id === drillId);
            if (!drill) {
                showUploadStatus('error', 'Drill not found.');
                return;
            }
            
            currentEditingDrillId = drillId;
            
            // Populate edit form
            document.getElementById('edit-drill-name').value = drill.name;
            document.getElementById('edit-drill-skill').value = drill.skill;
            document.getElementById('edit-drill-duration').value = drill.duration;
            document.getElementById('edit-drill-description').value = drill.description;
            
            showEditDrillModal();
        }

        function saveEditedDrill() {
            const name = document.getElementById('edit-drill-name').value;
            const skill = document.getElementById('edit-drill-skill').value;
            const duration = document.getElementById('edit-drill-duration').value;
            const description = document.getElementById('edit-drill-description').value;
            
            if (!name || !skill || !duration || !description) {
                alert('Please fill in all required fields.');
                return;
            }
            
            const drill = drills.find(d => d.id === currentEditingDrillId);
            if (drill) {
                drill.name = name;
                drill.skill = skill;
                drill.duration = duration;
                drill.description = description;
                
                renderDrillsTable();
                closeEditDrillModal();
                showUploadStatus('success', `Drill "${name}" has been updated.`);
            }
        }

        function confirmDeleteDrill(drillId) {
            if (currentUserRole !== 'admin') {
                showUploadStatus('error', 'Only administrators can delete drills.');
                return;
            }
            
            const drill = drills.find(d => d.id === drillId);
            if (!drill) {
                showUploadStatus('error', 'Drill not found.');
                return;
            }
            
            document.getElementById('modalIcon').textContent = '🗑️';
            document.getElementById('modalTitle').textContent = 'Delete Drill';
            document.getElementById('modalMessage').innerHTML = `
                <p>Are you sure you want to delete the drill:</p>
                <p><strong>"${drill.name}"</strong></p>
                <p>This action cannot be undone.</p>
            `;
            
            const confirmButton = document.getElementById('confirmButton');
            confirmButton.textContent = 'Delete';
            confirmButton.className = 'modal-btn confirm';
            
            confirmationAction = () => {
                const index = drills.findIndex(d => d.id === drillId);
                if (index >= 0) {
                    drills.splice(index, 1);
                    renderDrillsTable();
                    showUploadStatus('success', `Drill "${drill.name}" has been deleted.`);
                }
            };
            
            showConfirmationModal();
        }

        // Calendar Event management functions
        function downloadAllEvents() {
            const eventsData = {
                version: "1.0",
                exported: new Date().toISOString(),
                events: calendarEvents
            };
            
            const json = JSON.stringify(eventsData, null, 2);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `calendar_events_export_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showCalendarUploadStatus('success', `Downloaded ${calendarEvents.length} calendar events to JSON file.`);
        }

        function uploadEvents(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    let importedEvents = data.events || data; // Handle both wrapped and direct array formats
                    
                    if (!Array.isArray(importedEvents)) {
                        throw new Error('Invalid file format: expected array of calendar events');
                    }
                    
                    // Validate calendar event structure
                    const requiredFields = ['date', 'time', 'type', 'name', 'location', 'details'];
                    for (let calEvent of importedEvents) {
                        for (let field of requiredFields) {
                            if (!calEvent[field]) {
                                throw new Error(`Invalid calendar event structure: missing field '${field}'`);
                            }
                        }
                        // Ensure attendees array exists
                        if (!calEvent.attendees) {
                            calEvent.attendees = [];
                        }
                        // Ensure availability object exists
                        if (!calEvent.availability) {
                            calEvent.availability = { manus: '', andy: '', james: '' };
                        }
                    }
                    
                    // Show confirmation modal for import options
                    showEventImportConfirmation(importedEvents);
                    
                } catch (error) {
                    showCalendarUploadStatus('error', `Error reading file: ${error.message}`);
                }
                
                // Clear the file input for next upload
                event.target.value = '';
            };
            reader.readAsText(file);
        }

        function showEventImportConfirmation(importedEvents) {
            const existingCount = calendarEvents.length;
            const importCount = importedEvents.length;
            
            document.getElementById('modalIcon').textContent = '📤';
            document.getElementById('modalTitle').textContent = 'Import Calendar Events';
            document.getElementById('modalMessage').innerHTML = `
                <p>Found ${importCount} calendar events to import.</p>
                <p>Current calendar contains ${existingCount} events.</p>
                <p><strong>Choose import mode:</strong></p>
                <div style="margin-top: 12px;">
                    <label style="display: block; margin-bottom: 8px;">
                        <input type="radio" name="importMode" value="append" checked> 
                        <strong>Append:</strong> Add new events to existing ones
                    </label>
                    <label style="display: block; margin-bottom: 8px;">
                        <input type="radio" name="importMode" value="update"> 
                        <strong>Update:</strong> Replace events with matching names and dates
                    </label>
                    <label style="display: block;">
                        <input type="radio" name="importMode" value="replace"> 
                        <strong>Replace All:</strong> Delete existing and import new events
                    </label>
                </div>
            `;
            
            const confirmButton = document.getElementById('confirmButton');
            confirmButton.textContent = 'Import';
            confirmButton.className = 'modal-btn primary';
            
            confirmationAction = () => {
                const mode = document.querySelector('input[name="importMode"]:checked').value;
                processEventImport(importedEvents, mode);
            };
            
            showConfirmationModal();
        }

        function processEventImport(importedEvents, mode) {
            let added = 0, updated = 0, replaced = 0;
            
            try {
                switch (mode) {
                    case 'append':
                        importedEvents.forEach(calEvent => {
                            calendarEvents.push(calEvent);
                            added++;
                        });
                        break;
                        
                    case 'update':
                        importedEvents.forEach(importEvent => {
                            const existingIndex = calendarEvents.findIndex(e => e.name === importEvent.name && e.date === importEvent.date);
                            if (existingIndex >= 0) {
                                calendarEvents[existingIndex] = importEvent;
                                updated++;
                            } else {
                                calendarEvents.push(importEvent);
                                added++;
                            }
                        });
                        break;
                        
                    case 'replace':
                        calendarEvents.length = 0; // Clear existing events
                        importedEvents.forEach(calEvent => {
                            calendarEvents.push(calEvent);
                            replaced++;
                        });
                        break;
                }
                
                renderEventsTable();
                renderCalendar();
                
                let message = '';
                if (mode === 'replace') {
                    message = `Replaced all events with ${replaced} imported events.`;
                } else {
                    message = `Import complete: ${added} added, ${updated} updated.`;
                }
                showCalendarUploadStatus('success', message);
                
            } catch (error) {
                showCalendarUploadStatus('error', `Error importing calendar events: ${error.message}`);
            }
        }

        function showCalendarUploadStatus(type, message) {
            // Update calendar status div (if it exists in calendar section)
            const calendarStatusDiv = document.getElementById('upload-status-calendar');
            
            if (calendarStatusDiv) {
                calendarStatusDiv.className = `upload-status ${type}`;
                calendarStatusDiv.textContent = message;
                calendarStatusDiv.style.display = 'block';
            }
            
            // Update system calendar status div (in admin section)
            const calendarSystemStatusDiv = document.getElementById('upload-status-calendar-system');
            
            if (calendarSystemStatusDiv) {
                calendarSystemStatusDiv.className = `upload-status ${type}`;
                calendarSystemStatusDiv.textContent = message;
                calendarSystemStatusDiv.style.display = 'block';
            }
            
            // Also use the general showUploadStatus for consistency
            showUploadStatus(type, message);
            
            setTimeout(() => {
                if (calendarStatusDiv) {
                    calendarStatusDiv.style.display = 'none';
                }
                if (calendarSystemStatusDiv) {
                    calendarSystemStatusDiv.style.display = 'none';
                }
            }, 5000);
        }

        function confirmDeleteAllEvents() {
            if (currentUserRole !== 'admin') {
                showCalendarUploadStatus('error', 'Only administrators can delete all calendar events.');
                return;
            }
            
            document.getElementById('modalIcon').textContent = '🗑️';
            document.getElementById('modalTitle').textContent = 'Delete All Calendar Events';
            document.getElementById('modalMessage').innerHTML = `
                <p><strong>⚠️ WARNING: This action cannot be undone!</strong></p>
                <p>This will permanently delete all ${calendarEvents.length} calendar events in the repository.</p>
                <p>Consider downloading a backup first.</p>
            `;
            
            const confirmButton = document.getElementById('confirmButton');
            confirmButton.textContent = 'Delete All';
            confirmButton.className = 'modal-btn confirm';
            
            confirmationAction = () => {
                calendarEvents.length = 0; // Clear all calendar events
                renderEventsTable();
                renderCalendar();
                showCalendarUploadStatus('success', 'All calendar events have been deleted.');
            };
            
            showConfirmationModal();
        }

        // Modal management functions
        function showConfirmationModal() {
            document.getElementById('confirmationModal').classList.add('show');
        }

        function closeConfirmationModal() {
            document.getElementById('confirmationModal').classList.remove('show');
            confirmationAction = null;
        }

        function confirmAction() {
            if (confirmationAction) {
                confirmationAction();
                closeConfirmationModal();
            }
        }

        function showEditDrillModal() {
            document.getElementById('editDrillModal').classList.add('show');
        }

        function closeEditDrillModal() {
            document.getElementById('editDrillModal').classList.remove('show');
            currentEditingDrillId = null;
        }

        // Calendar Event editing functions
        function editCalendarEvent(eventIndex) {
            currentEditingEventIndex = eventIndex;
            const event = calendarEvents[eventIndex];
            
            if (!event) {
                alert('Event not found.');
                return;
            }
            
            // Populate form fields
            document.getElementById('edit-event-name').value = event.name;
            document.getElementById('edit-event-location').value = event.location || '';
            document.getElementById('edit-event-date').value = event.date;
            document.getElementById('edit-event-time').value = event.time;
            document.getElementById('edit-event-type').value = event.type;
            document.getElementById('edit-event-details').value = event.details || '';
            
            showEditEventModal();
        }

        function saveEditedEvent() {
            const name = document.getElementById('edit-event-name').value;
            const location = document.getElementById('edit-event-location').value;
            const date = document.getElementById('edit-event-date').value;
            const time = document.getElementById('edit-event-time').value;
            const type = document.getElementById('edit-event-type').value;
            const details = document.getElementById('edit-event-details').value;
            
            if (!name || !date || !time || !type) {
                alert('Please fill in all required fields.');
                return;
            }
            
            // Update the event
            const event = calendarEvents[currentEditingEventIndex];
            event.name = name;
            event.location = location;
            event.date = date;
            event.time = time;
            event.type = type;
            event.details = details;
            
            // Re-render both table and calendar
            renderEventsTable();
            renderCalendar();
            closeEditEventModal();
        }

        function showEditEventModal() {
            document.getElementById('editEventModal').classList.add('show');
        }

        function closeEditEventModal() {
            document.getElementById('editEventModal').classList.remove('show');
            currentEditingEventIndex = null;
        }

        // Pinch-to-zoom functionality for events table
        function initializePinchZoom() {
            const eventsTableContainer = document.querySelector('.events-list-container .table-container');
            if (!eventsTableContainer) return;

            let initialDistance = 0;
            let initialZoom = tableZoomLevel;

            function getDistance(touches) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function applyZoom(zoomLevel) {
                tableZoomLevel = Math.max(minZoom, Math.min(maxZoom, zoomLevel));
                
                // Apply zoom by scaling font sizes
                const header = eventsTableContainer.querySelector('.table-header');
                const rows = eventsTableContainer.querySelectorAll('.table-row');
                
                if (header) {
                    header.style.fontSize = (14 * tableZoomLevel) + 'px';
                }
                
                rows.forEach(row => {
                    const eventTitle = row.querySelector('.event-title');
                    const otherCells = row.querySelectorAll('div:not(.event-title)');
                    
                    if (eventTitle) {
                        eventTitle.style.fontSize = (15 * tableZoomLevel) + 'px';
                    }
                    
                    otherCells.forEach(cell => {
                        cell.style.fontSize = (14 * tableZoomLevel) + 'px';
                    });
                    
                    // Scale badges as well
                    const badges = row.querySelectorAll('.event-type-badge');
                    badges.forEach(badge => {
                        badge.style.fontSize = (12 * tableZoomLevel) + 'px';
                    });
                });
                
                // Also scale the table container padding for better touch targets
                const scaledPadding = Math.max(8, 16 * tableZoomLevel);
                header.style.padding = scaledPadding + 'px 20px';
                rows.forEach(row => {
                    row.style.padding = scaledPadding + 'px 20px';
                });
            }

            eventsTableContainer.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    isZooming = true;
                    initialDistance = getDistance(e.touches);
                    initialZoom = tableZoomLevel;
                }
            }, { passive: false });

            eventsTableContainer.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2 && isZooming) {
                    e.preventDefault();
                    const currentDistance = getDistance(e.touches);
                    const scale = currentDistance / initialDistance;
                    const newZoom = initialZoom * scale;
                    
                    applyZoom(newZoom);
                }
            }, { passive: false });

            eventsTableContainer.addEventListener('touchend', function(e) {
                if (e.touches.length < 2) {
                    isZooming = false;
                }
            });

            // Apply initial zoom
            applyZoom(tableZoomLevel);
        }

        // Issue Management Functions
        function showLogIssueForm() {
            document.getElementById('logIssueModal').style.display = 'flex';
            // Clear form fields
            document.getElementById('issue-title').value = '';
            document.getElementById('issue-description').value = '';
        }

        function closeLogIssueModal() {
            document.getElementById('logIssueModal').style.display = 'none';
        }

        function saveIssue() {
            const title = document.getElementById('issue-title').value.trim();
            const description = document.getElementById('issue-description').value.trim();
            
            if (!title || !description) {
                showIssueStatus('Please fill in both title and description.', 'error');
                return;
            }
            
            // Create new issue object
            const issue = {
                id: Date.now(), // Simple ID generation for frontend-only storage
                title: title,
                description: description,
                dateLogged: new Date().toISOString().split('T')[0], // YYYY-MM-DD format
                status: 'Open' // Default status
            };
            
            // Add to issues array
            issues.unshift(issue); // Add to beginning for newest first
            
            // Close modal and show success message
            closeLogIssueModal();
            showIssueStatus('Issue logged successfully!', 'success');
            
            // If issues table is open, refresh it
            if (document.getElementById('issuesTableModal').style.display === 'flex') {
                renderIssuesTable();
            }
        }

        function showIssuesTable() {
            document.getElementById('issuesTableModal').style.display = 'flex';
            renderIssuesTable();
        }

        function closeIssuesTableModal() {
            document.getElementById('issuesTableModal').style.display = 'none';
        }

        function renderIssuesTable() {
            const tableBody = document.getElementById('issues-table-body');
            const noIssuesMessage = document.getElementById('no-issues-message');
            
            if (issues.length === 0) {
                tableBody.style.display = 'none';
                noIssuesMessage.style.display = 'block';
                return;
            }
            
            tableBody.style.display = 'block';
            noIssuesMessage.style.display = 'none';
            
            tableBody.innerHTML = '';
            
            issues.forEach(issue => {
                const row = document.createElement('div');
                row.className = 'table-row';
                row.innerHTML = `
                    <div style="flex: 2; font-weight: 600;">${issue.title}</div>
                    <div style="flex: 3;">
                        <div style="max-height: 60px; overflow: hidden; text-overflow: ellipsis;">
                            ${issue.description}
                        </div>
                    </div>
                    <div style="flex: 1;">${issue.dateLogged}</div>
                    <div style="flex: 1;">
                        <span class="status-badge status-${issue.status.toLowerCase()}">${issue.status}</span>
                    </div>
                `;
                tableBody.appendChild(row);
            });
        }

        function showIssueStatus(message, type) {
            const statusDiv = document.getElementById('upload-status-issues');
            statusDiv.className = `upload-status ${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            // Hide after 3 seconds
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        window.showSection = showSection;
    </script>
